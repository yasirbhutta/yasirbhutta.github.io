course: python
topics:
  - topic: oop-abstraction
    questions:
      - id: abs001
        difficulty: easy
        question: What is the primary purpose of abstraction in OOP?
        language: python
        code: ""
        options:
          - "To hide implementation details and show only essential features"
          - "To allow multiple inheritance in Python"
          - "To enforce strict type checking"
          - "To optimize code performance"
        answer: "To hide implementation details and show only essential features"
        explanation: Abstraction focuses on exposing only necessary features while hiding complex implementation details.

      - id: abs002
        difficulty: medium
        question: How is abstraction typically achieved in Python?
        language: python
        code: ""
        options:
          - "Using private methods with `__` prefix"
          - "Using abstract base classes (ABC) and `@abstractmethod`"
          - "Through function decorators only"
          - "By overloading operators"
        answer: "Using abstract base classes (ABC) and `@abstractmethod`"
        explanation: Python uses the `abc` module and `@abstractmethod` decorator to enforce abstraction by requiring subclasses to implement specific methods.

      - id: abs003
        difficulty: easy
        question: What will happen if a subclass doesn't implement an abstract method?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Animal(ABC):
              @abstractmethod
              def sound(self):
                  pass
          
          class Dog(Animal):
              pass
          obj = Dog()
        options:
          - "The code will run without errors"
          - "TypeError at class definition"
          - "TypeError at instantiation"
          - "The method will inherit the parent's implementation"
        answer: "TypeError at instantiation"
        explanation: Python raises a `TypeError` when you try to instantiate a subclass that doesn't implement all abstract methods.

      - id: abs004
        difficulty: medium
        question: Which module is required to create abstract classes in Python?
        language: python
        code: ""
        options:
          - "`abstract`"
          - "`abc`"
          - "`oop`"
          - "`abstractmethod` only (no module needed)"
        answer: "`abc`"
        explanation: The `abc` module provides the `ABC` metaclass and `@abstractmethod` decorator for creating abstract classes.

      - id: abs005
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Shape(ABC):
              @abstractmethod
              def area(self):
                  pass
          
          class Square(Shape):
              def __init__(self, side):
                  self.side = side
              def area(self):
                  return self.side ** 2
          
          s = Square(4)
          print(s.area())
        options:
          - "0"
          - "16"
          - "TypeError (Shape cannot be instantiated)"
          - "Error (Square doesn't implement `area()`)"
        answer: "16"
        explanation: Since `Square` properly implements the abstract `area()` method, it can be instantiated, and the calculation works correctly.

      - id: abs006
        difficulty: medium
        question: Which of the following is TRUE about abstraction in Python?
        language: python
        code: ""
        options:
          - "Abstract methods can have implementations in the parent class"
          - "A class with at least one abstract method can be instantiated"
          - "Abstract classes must inherit from `object`"
          - "Abstract methods can be declared without the `abc` module"
        answer: "Abstract methods can have implementations in the parent class"
        explanation: Abstract methods in Python can have implementations, but subclasses must still override them. The `@abstractmethod` decorator marks them as requiring override.

      - id: abs007
        difficulty: easy
        question: What does the `@abstractmethod` decorator do?
        language: python
        code: ""
        options:
          - "Prevents a method from being called"
          - "Marks a method as requiring implementation in subclasses"
          - "Makes a method private"
          - "Optimizes method execution speed"
        answer: "Marks a method as requiring implementation in subclasses"
        explanation: The `@abstractmethod` decorator enforces that concrete subclasses must implement the decorated method.

      - id: abst001
        difficulty: easy
        question: What is abstraction in object-oriented programming?
        options:
          - "Hiding the internal implementation and showing only the necessary features"
          - "Creating private variables"
          - "Restricting access using access modifiers"
          - "Writing multiple methods with the same name"
        answer: "Hiding the internal implementation and showing only the necessary features"
        explanation: Abstraction is the concept of hiding complex implementation details and showing only the essential features to the user.

      - id: abst002
        difficulty: medium
        question: Which module in Python provides the base class for creating abstract classes?
        options:
          - "abc"
          - "abstract"
          - "base"
          - "oop"
        answer: "abc"
        explanation: The `abc` module in Python provides infrastructure for defining Abstract Base Classes.

      - id: abst003
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          from abc import ABC, abstractmethod

          class Shape(ABC):
              @abstractmethod
              def area(self):
                  pass

          class Circle(Shape):
              def area(self):
                  return 3.14 * 4 * 4

          c = Circle()
          print(c.area())
        options:
          - "50.24"
          - "Error: Can't instantiate abstract class"
          - "None"
          - "8"
        answer: "50.24"
        explanation: Since the `Circle` class implements the abstract method `area`, it can be instantiated and will return the calculated area.

      - id: abst004
        difficulty: easy
        question: What will happen if you try to instantiate an abstract class with an unimplemented abstract method?
        options:
          - "It will raise a TypeError"
          - "It will return None"
          - "It will call the method with default implementation"
          - "It will execute without any error"
        answer: "It will raise a TypeError"
        explanation: Python will raise a `TypeError` if you attempt to instantiate an abstract class that has unimplemented abstract methods.

      - id: abst005
        difficulty: medium
        question: Why do we use abstract base classes in Python?
        options:
          - "To enforce certain methods in subclasses"
          - "To allow direct instantiation"
          - "To reduce memory usage"
          - "To avoid using constructors"
        answer: "To enforce certain methods in subclasses"
        explanation: Abstract base classes are used to define a common interface and enforce that derived classes implement specific methods.
        
      - id: abs008
        difficulty: medium
        question: What is the output of this code?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Database(ABC):
              @abstractmethod
              def connect(self):
                  print("Default connection logic")
          
          class MySQL(Database):
              def connect(self):
                  super().connect()
                  print("MySQL connection")
          
          db = MySQL()
          db.connect()
        options:
          - "`MySQL connection`"
          - "`Default connection logic` followed by `MySQL connection`"
          - "TypeError (cannot instantiate abstract class)"
          - "Error: `super()` misuse"
        answer: "`Default connection logic` followed by `MySQL connection`"
        explanation: "Abstract methods CAN have implementations in Python. The subclass invokes the parent's implementation via `super()`."

      - id: abs009
        difficulty: hard
        question: Why does this code fail?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Logger(ABC):
              @abstractmethod
              def log(self, message):
                  pass
          
              @abstractmethod
              def close(self):
                  pass
          
          class FileLogger(Logger):
              def log(self, message):
                  print(f"Log: {message}")
          
          logger = FileLogger()  # Error occurs here
        options:
          - "Missing `close()` implementation in `FileLogger`"
          - "Abstract methods cannot have parameters like `message`"
          - "`FileLogger` must inherit from `object` first"
          - "`@abstractmethod` cannot be used twice"
        answer: "Missing `close()` implementation in `FileLogger`"
        explanation: "Subclasses must implement ALL abstract methods. Here, `close()` is missing."

      - id: abs010
        difficulty: medium
        question: What does this code demonstrate about abstraction?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class PaymentGateway(ABC):
              @abstractmethod
              def process_payment(self, amount):
                  pass
          
              def receipt(self, amount):
                  print(f"Receipt for ${amount}")
          
          class PayPal(PaymentGateway):
              def process_payment(self, amount):
                  print(f"Processing ${amount} via PayPal")
          
          payment = PayPal()
          payment.process_payment(100)
          payment.receipt(100)
        options:
          - "Abstract classes can have both abstract and concrete methods"
          - "`receipt()` must also be abstract"
          - "Subclasses cannot use parent's concrete methods"
          - "Abstract methods must return a value"
        answer: "Abstract classes can have both abstract and concrete methods"
        explanation: "The `receipt()` method is fully implemented in the abstract class and shared by all subclasses."

      - id: abs011
        difficulty: hard
        question: What is the key problem in this design?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Vehicle(ABC):
              @abstractmethod
              def start_engine(self):
                  pass
          
              @abstractmethod
              def stop_engine(self):
                  pass
          
          class Bicycle(Vehicle):
              def start_engine(self):
                  raise NotImplementedError("Bicycles have no engine!")
          
              def stop_engine(self):
                  raise NotImplementedError("Bicycles have no engine!")
        options:
          - "Violates Liskov Substitution Principle (Bicycle isn't a valid Vehicle)"
          - "`NotImplementedError` should be replaced with `pass`"
          - "Abstract methods cannot raise exceptions"
          - "Missing `@abstractmethod` decorator in `Bicycle`"
        answer: "Violates Liskov Substitution Principle (Bicycle isn't a valid Vehicle)"
        explanation: "Forcing `Bicycle` to implement engine methods indicates a flawed abstraction hierarchy."

      - id: abs012
        difficulty: easy
        question: What is the purpose of `ABC.register()` here?
        language: python
        code: |
          from abc import ABC
          class Duck:
              def quack(self):
                  print("Quack!")
          
          class Bird(ABC):
              @classmethod
              def __subclasshook__(cls, subclass):
                  return hasattr(subclass, 'quack')
          
          Bird.register(Duck)
          duck = Duck()
          print(isinstance(duck, Bird))  # Output: True
        options:
          - "Ensures `Duck` implements all abstract methods of `Bird`"
          - "Dynamically registers `Duck` as a virtual subclass of `Bird`"
          - "Prevents `Duck` from being instantiated"
          - "Creates a strict inheritance relationship"
        answer: "Dynamically registers `Duck` as a virtual subclass of `Bird`"
        explanation: "`register()` allows non-inheriting classes to be treated as subclasses if they meet the interface (duck typing)."

      - id: abs013
        difficulty: medium
        question: What makes this code a proper abstraction?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class DataExporter(ABC):
              @abstractmethod
              def export(self, data):
                  pass
          
              def validate(self, data):
                  return isinstance(data, list)
          
          class CSVExporter(DataExporter):
              def export(self, data):
                  if self.validate(data):
                      print(f"Exporting {len(data)} rows to CSV")
                  else:
                      raise ValueError("Invalid data format")
          
          exporter = CSVExporter()
          exporter.export([1, 2, 3])
        options:
          - "It hides validation logic inside the abstract class"
          - "It forces subclasses to implement `export()` but shares `validate()`"
          - "It uses `ABC` to prevent instantiation"
          - "All of the above"
        answer: "All of the above"
        explanation: "This demonstrates encapsulation (validation hiding), method enforcement (`export()`), and reusable shared logic (`validate()`)."

  - topic: oop-encapsulation
    questions:
      - id: encap001
        difficulty: easy
        question: What is encapsulation in Python OOP?
        options:
          - "A way to hide internal implementation details and expose only necessary features"
          - "A method to combine multiple functions into one"
          - "A technique to make code run faster"
          - "A way to remove unused variables"
        answer: "A way to hide internal implementation details and expose only necessary features"
        explanation: Encapsulation helps in restricting access to certain components and prevents unintended modifications.

      - id: encap002
        difficulty: easy
        question: How do you make an attribute private in Python?
        options:
          - "By using the `private` keyword"
          - "By prefixing the attribute name with a single underscore `_`"
          - "By prefixing the attribute name with double underscores `__`"
          - "By using the `hidden` keyword"
        answer: "By prefixing the attribute name with double underscores `__`"
        explanation: In Python, double underscores `__` make an attribute name-mangled, restricting direct access.

      - id: encap003
        difficulty: easy
        question: What is the purpose of getter and setter methods in encapsulation?
        options:
          - "To directly modify private attributes"
          - "To control access and modification of private attributes"
          - "To delete unused variables"
          - "To improve code execution speed"
        answer: "To control access and modification of private attributes"
        explanation: Getters and setters allow controlled access to private attributes, enabling validation or modification checks.

      - id: encap004
        difficulty: medium
        question: Which of the following is true about name mangling in Python?
        options:
          - "It makes an attribute completely inaccessible"
          - "It renames the attribute to `_ClassName__attribute`"
          - "It deletes the attribute after use"
          - "It is done using the `@mangle` decorator"
        answer: "It renames the attribute to `_ClassName__attribute`"
        explanation: Name mangling changes the attribute name to `_ClassName__attribute` to avoid accidental access.

      - id: encap005
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class BankAccount:
              def __init__(self):
                  self.__balance = 100

              def get_balance(self):
                  return self.__balance

          acc = BankAccount()
          print(acc.__balance)
        options:
          - "100"
          - "Error: AttributeError (private attribute access)"
          - "None"
          - "0"
        answer: "Error: AttributeError (private attribute access)"
        explanation: Double underscores make `__balance` private, so direct access outside the class raises an error.

      - id: encap006
        difficulty: easy
        question: What is the correct way to access a private attribute from outside its class?
        options:
          - "By using the `public` keyword"
          - "By calling `object._attribute`"
          - "By using a getter method"
          - "By using `object.__attribute`"
        answer: "By using a getter method"
        explanation: The safest way is to use a getter method (e.g., `get_balance()`) instead of direct access.

      - id: encap007
        difficulty: medium
        question: Which keyword is used to define a read-only property in Python?
        options:
          - "`@readonly`"
          - "`@property`"
          - "`@getter`"
          - "`@final`"
        answer: "`@property`"
        explanation: The `@property` decorator allows defining a method as a read-only attribute.

      - id: encap008
        difficulty: easy
        question: What is the purpose of the single underscore `_` before a variable name?
        options:
          - "It makes the variable private"
          - "It indicates that the variable is for internal use (convention)"
          - "It makes the variable global"
          - "It prevents the variable from being modified"
        answer: "It indicates that the variable is for internal use (convention)."
        explanation: A single underscore is a naming convention to suggest that a variable is for internal use (not enforced by Python). It should be accessed only within the class or its subclasses.

      - id: encap009
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Student:
              def __init__(self):
                  self.__name = "Alice"
          
          s = Student()
          print(s.__name)
        options:
          - "Alice"
          - "None"
          - "Error: AttributeError (private attribute access)"
          - "'' (empty string)"
        answer: "Error: AttributeError (private attribute access)"
        explanation: Private attributes (prefixed with `__`) cannot be accessed directly outside the class.

      - id: encap010
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Student:
              def __init__(self):
                  self.__name = "Alice"
              
              def get_name(self):
                  return self.__name
          
          s = Student()
          print(s.get_name())
        options:
          - "Alice"
          - "Error: Method not defined"
          - "None"
          - "'' (empty string)"
        answer: "Alice"
        explanation: The `get_name()` method provides controlled access to the private `__name` attribute.

      - id: encap011
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Temperature:
              def __init__(self):
                  self.__celsius = 30
              
              def get_fahrenheit(self):
                  return (self.__celsius * 9/5) + 32
          
          t = Temperature()
          print(t.get_fahrenheit())
        options:
          - "30"
          - "86"
          - "Error: AttributeError"
          - "None"
        answer: "86"
        explanation: The private `__celsius` is used internally to compute Fahrenheit (30°C = 86°F).

      - id: encap012
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Account:
              def __init__(self):
                  self.__balance = 0
              
              def deposit(self, amount):
                  self.__balance += amount
              
              def withdraw(self, amount):
                  if amount <= self.__balance:
                      self.__balance -= amount
                  else:
                      print("Insufficient funds!")
              
              def get_balance(self):
                  return self.__balance
          
          acc = Account()
          acc.deposit(100)
          acc.withdraw(30)
          print(acc.get_balance())
        options:
          - "0"
          - "70"
          - "100"
          - "Error"
        answer: "70"
        explanation: The private `__balance` is modified only via methods (`deposit()` and `withdraw()`).

      - id: encap013
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Person:
              def __init__(self):
                  self.__age = 25
              
              @property
              def age(self):
                  return self.__age
              
              @age.setter
              def age(self, value):
                  if value > 0:
                      self.__age = value
                  else:
                      print("Invalid age!")
          
          p = Person()
          p.age = -5
          print(p.age)
        options:
          - "-5"
          - "25"
          - "0"
          - "Invalid age!"
        answer: "25"
        explanation: The setter rejects negative values, so `__age` remains unchanged (25).

      - id: encap014
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Car:
              def __init__(self):
                  self.__speed = 0
              
              def accelerate(self):
                  self.__speed += 10
              
              def brake(self):
                  self.__speed = max(0, self.__speed - 10)
              
              def get_speed(self):
                  return self.__speed
          
          c = Car()
          c.accelerate()  # Typo in method name
          print(c.get_speed())
        options:
          - "0"
          - "10"
          - "Error: AttributeError"
          - "Error: Method not found"
        answer: "Error: Method not found"
        explanation: The typo `accelerate()` → `accelerate()` causes an `AttributeError`.

      - id: encap015
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          class Secret:
              def __init__(self):
                  self.__key = "1234"
              
              def _get_key(self):
                  return self.__key[::-1]  # Reversed
          
          s = Secret()
          print(s._get_key())
        options:
          - "1234"
          - "4321"
          - "Error: Private method access"
          - "None"
        answer: "4321"
        explanation: Single underscore `_get_key()` is

  - topic: oop-inheritance
    questions:
      - id: inh001
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Animal:
              def speak(self):
                  print("Animal speaks")

          class Dog(Animal):
              pass

          d = Dog()
          d.speak()
        options:
          - Animal speaks
          - Dog speaks
          - "Error: **speak()** not defined"
          - Nothing
        answer: Animal speaks
        explanation: Dog inherits the `speak()` method from Animal.

      - id: py-inh-002
        difficulty: medium
        question: |
          What is the output of the following Python code?
        language: python
        code: |
          class Parent:
              def greet(self):
                  print("Hello from Parent")

          class Child(Parent):
              def greet(self):
                  print("Hello from Child")
                  Parent.greet(self)     
                  super().greet()         

          obj = Child()
          obj.greet()
        options:
          - |
            Hello from Child
            Hello from Parent
            Hello from Parent
          - |
            Hello from Parent
            Hello from Child
            Hello from Parent
          - |
            Hello from Child
            Hello from Child
            Hello from Parent
          - |
            Hello from Parent
            Hello from Parent
            Hello from Child
        answer: |
          Hello from Child
          Hello from Parent
          Hello from Parent
        explanation: |
          The `Child.greet()` method prints "Hello from Child", then explicitly calls `Parent.greet(self)` and `super().greet()`, both of which call the `Parent` class's `greet()` method, resulting in "Hello from Parent" printed twice.

      - id: py-inh-001
        difficulty: easy
        question: What is the main purpose of inheritance in Python?
        options:
          - To create multiple objects of a class
          - To reuse code and extend functionality
          - To define private methods in a class
          - To create a new programming paradigm
        answer: To reuse code and extend functionality
        explanation: Inheritance allows code reuse and method overriding in child classes.
      - id: py002
        difficulty: easy
        question: Which of the following is the correct syntax for inheritance in Python?
        options:
          - "class Child inherits Parent:"
          - "class Child(Parent):"
          - "class Parent -> Child:"
          - "class Parent(Child):"
        answer: "class Child(Parent):"
        explanation: In Python, a child class is defined using the syntax `class Child(Parent):`, where `Child` inherits from `Parent`.
      - id: inh002
        difficulty: easy
        question: What is the output of the following code?
        code: |
          class Parent:
              def __init__(self):
                  print("Parent constructor")

          class Child(Parent):
              def __init__(self):
                  print("Child constructor")

          c = Child()
        options:
          - Parent constructor
          - Child constructor
          - Parent constructor Child constructor
          - Error
        answer: Child constructor
        explanation: The `Child` constructor overrides the `Parent` constructor.

      - id: inh003
        difficulty: medium
        question: What is the output of the following code?
        code: |
          class Parent:
              def show(self):
                  print("Parent")

          class Child(Parent):
              def show(self):
                  print("Child")

          obj = Child()
          obj.show()
        options:
          - Parent
          - Child
          - Parent Child
          - Error
        answer: Child

      - id: py-inh-001
        difficulty: easy
        question: What is the primary purpose of inheritance in Python?
        options:
          - To improve memory efficiency
          - To hide implementation details
          - To enable code reusability
          - To reduce program complexity
        answer: To enable code reusability
        explanation: Inheritance helps avoid code duplication by allowing child classes to reuse methods and properties of parent classes.

      - id: py-inh-002
        difficulty: easy
        question: Which syntax correctly defines a class `Child` inheriting from `Parent`?
        options:
          - class Child extends Parent:
          - class Child(Parent):
          - class Child inherits Parent:
          - class Child : Parent
        answer: "class Child(Parent):"
        explanation: In Python, inheritance is denoted by placing the parent class name in parentheses after the child class name.

      - id: py-inh-003
        difficulty: medium
        question: What is the output of the following code?
        code: |
          class Parent:
              def greet(self):
                  print("Hello from Parent!")
          
          class Child(Parent):
              def greet(self):
                  print("Hello from Child!")

          obj = Child()
          obj.greet()
        options:
          - Hello from Parent!
          - Hello from Child!
          - Error
          - No output
        answer: Hello from Child!
        explanation: The `greet` method is overridden in the `Child` class, so that version is called.

      - id: py-inh-004
        difficulty: medium
        question: What does the `super()` function do?
        options:
          - Returns the base class instance
          - Calls a method from a sibling class
          - Calls a method from the parent class
          - Creates a new subclass
        answer: Calls a method from the parent class
        explanation: "`super()` is used to call methods from the parent class, especially in method overrides"

      - id: py-inh-005
        difficulty: hard
        question: Which type of inheritance is NOT supported in Python?
        options:
          - Single
          - Multiple
          - Cascading
          - Multilevel
        answer: Cascading
        explanation: Python supports single, multiple, and multilevel inheritance, but "cascading" is not a recognized inheritance type.

      - id: py-inh-006
        difficulty: medium
        question: "In multiple inheritance, the method resolution order (MRO) follows:"
        options:
          - Depth-first search
          - Breadth-first search
          - C3 linearization
          - Random order
        answer: C3 linearization
        explanation: Python uses C3 linearization to determine the order in which classes are searched when executing a method.

      - id: py-inh-007
        difficulty: hard
        question: How do you explicitly call a parent class method from a child class?
        options:
          - Parent.method(self)
          - self.parent_method()
          - super().method()
          - Both A and C
        answer: Both A and C
        explanation: You can call a parent method using either `Parent.method(self)` or `super().method()`.

      - id: py-inh-008
        difficulty: hard
        question: Which statement about private members (e.g., `__var`) in inheritance is true?
        options:
          - They are directly accessible in subclasses
          - They are inaccessible due to name mangling
          - They can be accessed using `super()`
          - They are inherited without name mangling
        answer: They are inaccessible due to name mangling
        explanation: Private members with double underscores are name-mangled and not directly accessible from subclasses.

      - id: py-inh-009
        difficulty: medium
        question: What does `isinstance(child_obj, Parent)` return?
        options:
          - True
          - False
          - TypeError
          - None
        answer: True
        explanation: If `child_obj` is an instance of a class derived from `Parent`, `isinstance` will return `True`.

      - id: py-inh-010
        difficulty: hard
        question: "Hybrid inheritance refers to:"
        options:
          - Combining multiple types of inheritance
          - Inheriting from two parent classes
          - Overriding all parent methods
          - Using interfaces only
        answer: Combining multiple types of inheritance
        explanation: Hybrid inheritance is a combination of more than one type of inheritance, like multiple and multilevel.
    resources:
    - name: Learn Inheritance in Python
      url: https://yasirbhutta.github.io/python/docs/oop-inheritance.html

  - topic: oop-polymorphism
    questions:
      - id: py011
        difficulty: medium
        question: What is polymorphism in Python?
        options:
          - Inheritance of attributes from a class
          - The ability of different classes to provide different implementations of the same method
          - The process of creating objects from a class
          - None of the above
        answer: The ability of different classes to provide different implementations of the same method
        explanation: Polymorphism allows methods to be defined in multiple classes with different implementations.
      - id: py012
        difficulty: medium
        question: Which function is used to determine the type of an object in Python?
        options:
          - type()
          - isinstance()
          - object()
          - None of the above
        answer: type()
        explanation: The `type()` function is used to determine the type of an object in Python.
    resources:
    - name: Learn Polymorphism in Python
      url: https://yasirbhutta.github.io/python/docs/oop-polymorphism.html

  - topic: strings
    questions:
      - id: py-str-001
        difficulty: easy
        question: What will be the output of the following code?
        code: |
          name = "Alice"
          print(name[1])
        options:
          - A
          - l
          - i
          - e
        answer: l
        explanation: Indexing in strings starts at 0, so `name[1]` gives the second character, which is 'l'.

      - id: py-str-002
        difficulty: easy
        question: Which method converts a string to all uppercase letters?
        options:
          - capitalize()
          - upper()
          - title()
          - swapcase()
        answer: upper()
        explanation: The `upper()` method converts all characters in a string to uppercase.

      - id: py-str-003
        difficulty: easy
        question: What does the `strip()` method do?
        options:
          - Removes only leading spaces
          - Removes only trailing spaces
          - Removes both leading and trailing spaces
          - Removes all spaces inside the string
        answer: Removes both leading and trailing spaces
        explanation: The `strip()` method removes whitespace from both ends of the string.

      - id: py-str-004
        difficulty: easy
        question: What is the output of the following code?
        code: |
          word = "HELLO"
          print(word.lower())
        options:
          - Hello
          - hello
          - HELLO
          - error
        answer: hello
        explanation: The `lower()` method converts all uppercase letters in a string to lowercase.

      - id: py-str-005
        difficulty: easy
        question: What is the output of this code?
        code: |
          text = "python"
          print(text.title())
        options:
          - Python
          - PYTHON
          - python
          - P y t h o n
        answer: Python

      - id: py-str-003
        difficulty: easy
        question: What does the `strip()` method do?
        options:
          - Removes only leading spaces
          - Removes only trailing spaces
          - Removes both leading and trailing spaces
          - Removes all spaces inside the string
        answer: Removes both leading and trailing spaces
        explanation: The `strip()` method removes whitespace from both ends of the string.

      - id: py-str-004
        difficulty: easy
        question: What is the output of the following code?
        code: |
          word = "HELLO"
          print(word.lower())
        options:
          - Hello
          - hello
          - HELLO
          - error
        answer: hello
        explanation: The `lower()` method converts all uppercase letters in a string to lowercase.

      - id: py-str-005
        difficulty: easy
        question: What is the output of the following code?
        code: |
          text = "python"
          print(text.title())
        options:
          - Python
          - PYTHON
          - python
          - P y t h o n
        answer: Python
        explanation: The `title()` method capitalizes the first letter of each word in the string.

      - id: py-str-001
        difficulty: easy
        question: What does the `split()` method return?
        options:
          - A single string
          - A tuple
          - A dictionary
          - A list of strings
        answer: A list of strings
        explanation: The `split()` method divides a string into a list based on a specified delimiter.

      - id: py-str-002
        difficulty: easy
        question: What will be the output of this code?
        code: |
          "apple,banana,grape".split(",")
        options:
          - "['apple', 'banana', 'grape']"
          - ('apple', 'banana', 'grape')
          - 'apple banana grape'
          - ['apple,banana,grape']
        answer: "['apple', 'banana', 'grape']"
        explanation: The `split(",")` method splits the string wherever it finds a comma and returns a list.

      - id: py-str-003
        difficulty: medium
        question: What does the `partition()` method return?
        options:
          - Only the substring before the separator
          - A list of split strings
          - A tuple of three parts
          - A dictionary of parts
        answer: A tuple of three parts
        explanation: "The artition() method splits a string into three parts: before the separator, the separator itself, and after."

      - id: py-str-004
        difficulty: easy
        question: Which method can be used to replace all occurrences of a substring with another substring?
        options:
          - change()
          - substitute()
          - switch()
          - replace()
        answer: replace()
        explanation: The `replace()` method is used to replace all occurrences of a specified substring.

      - id: py-str-005
        difficulty: medium
        question: What is the output of the following code?
        code: |
          "hello world".find("o")
        options:
          - 4
          - 5
          - 6
          - -1
        answer: 4
        explanation: The `find()` method returns the first index of the substring "o", which is 4.

    resources:
    - name: Learn String Methods & Formatting
      url: https://yasirbhutta.github.io/python/docs/strings.html

  - topic: lambda
    questions:
      - id: py-lambda-001
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          add_ten = lambda x: x + 10
          print(add_ten(5))
        options:
          - 15
          - 10
          - 5
          - 20
        answer: 15
        explanation: |
          The lambda function adds 10 to the given input. 5 + 10 = 15.

      - id: py-lambda-002
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          mul = lambda a, b: a * b
          print(mul(2, 4))
        options:
          - 6
          - 8
          - 4
          - 2
        answer: 8
        explanation: |
          The lambda function multiplies the two inputs: 2 * 4 = 8.

      - id: py-lambda-003
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          is_even = lambda x: x % 2 == 0
          print(is_even(6))
        options:
          - True
          - False
          - None
          - 0
        answer: True
        explanation: |
          6 is divisible by 2, so the lambda function returns True.

      - id: py-lambda-004
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          (lambda x, y: x + y)(6, 8)
        options:
          - 14
          - 48
          - 68
          - 86
        answer: 14
        explanation: |
          The lambda function adds 6 and 8, resulting in 14.

      - id: py-lambda-005
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          result = (lambda x, y: x * y)(5, 3)
          print(result)
        options:
          - 15
          - 8
          - 5
          - 3
        answer: 15
        explanation: |
          The lambda function multiplies 5 and 3, resulting in 15.

      - id: py-lambda-006
        difficulty: hard
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          multiply = lambda x, y: x * y
          mult = lambda x, y: multiply(x, y)
          result = mult(6, 2)
          print(result)
        options:
          - 8
          - 12
          - 6
          - 2
        answer: 12
        explanation: |
          The first lambda `multiply` multiplies two numbers. The second lambda `mult` calls the first, so 6 * 2 = 12.

    resources:
    - name: "Understanding Python Lambda Functions: A Comprehensive Guide"
      url: https://yasirbhutta.github.io/python/docs/lambda/