course: python
topics:
  - topic: lists
    questions:
      - id: list001
        difficulty: easy
        question: What is the correct way to create an empty list in Python?
        language: python
        options:
          - "[]"
          - "list()"
          - "Both of the above"
          - "None of the above"
        answer: "Both of the above"
        explanation: "Both [] and list() can be used to create an empty list in Python."

      - id: list002
        difficulty: easy
        question: What will be the output of the following code?
        language: python
        code: |
          my_list = ['a', 'b', 'c']
          print(my_list[1])
        options:
          - "'a'"
          - "'b'"
          - "'c'"
          - "Error"
        answer: "'b'"
        explanation: "List indices start at 0, so index 1 refers to the second element 'b'."

      - id: list003
        difficulty: medium
        question: What does the following code return?
        language: python
        code: |
          nums = [0, 1, 2, 3, 4, 5]
          print(nums[1:4])
        options:
          - "[0, 1, 2, 3]"
          - "[1, 2, 3]"
          - "[1, 2, 3, 4]"
          - "[0, 1, 2]"
        answer: "[1, 2, 3]"
        explanation: "Slicing is inclusive of the start index and exclusive of the end index."

      - id: list004
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          numbers = [1, 2, 3, 4]
          print(numbers[::-1])
        options:
          - "[1, 2, 3, 4]"
          - "[4, 3, 2, 1]"
          - "[4]"
          - "Error"
        answer: "[4, 3, 2, 1]"
        explanation: "The [::-1] slice creates a reversed copy of the list."

      - id: list005
        difficulty: easy
        question: Which method adds an element to the end of a list?
        language: python
        options:
          - "append()"
          - "add()"
          - "insert()"
          - "extend()"
        answer: "append()"
        explanation: "The append() method adds a single element to the end of the list."

      - id: list006
        difficulty: medium
        question: What is the difference between list.pop() and list.remove()?
        language: python
        options:
          - "pop() removes by index, remove() removes by value"
          - "pop() removes by value, remove() removes by index"
          - "Both remove by index"
          - "Both remove by value"
        answer: "pop() removes by index, remove() removes by value"
        explanation: "pop() removes and returns an item at the given index (last by default), while remove() deletes the first occurrence of the specified value."

      - id: list007
        difficulty: hard
        question: What will be the value of `a` after executing this code?
        language: python
        code: |
          a = [1, 2]
          b = [3, 4]
          a.extend(b)
          print(a)
        options:
          - "[1, 2, 3, 4]"
          - "[1, 2, [3, 4]]"
          - "[3, 4, 1, 2]"
          - "[1, 3, 2, 4]"
        answer: "[1, 2, 3, 4]"
        explanation: "extend() adds all elements of an iterable to the end of the list, flattening them."

  - topic: operators
    questions:
      - id: arith004
        difficulty: easy
        question: What is the output of `print(7 / 2)`?
        language: python
        code: "print(7 / 2)"
        options:
          - "3"
          - "3.5"
          - "3.0"
          - "4"
        answer: "3.5"
        explanation: "True division (/) always returns a float in Python 3."

      - id: arith005
        difficulty: hard
        question: What does `2 ** 3 ** 2` evaluate to?
        language: python
        code: "2 ** 3 ** 2"
        options:
          - "64"
          - "512"
          - "12"
          - "SyntaxError"
        answer: "512"
        explanation: "Exponentiation is right-associative: evaluates as 2 ** (3 ** 2) = 2^9 = 512."

      - id: arith006
        difficulty: medium
        question: What is the result of `10 // 3 * 2`?
        language: python
        code: "10 // 3 * 2"
        options:
          - "6"
          - "6.666"
          - "4"
          - "7"
        answer: "6"
        explanation: "Floor division (//) happens first (10//3=3), then multiplication (3*2=6)."

      - id: comp002
        difficulty: easy
        question: What does `print(5 == 5.0)` output?
        language: python
        code: "print(5 == 5.0)"
        options:
          - "True"
          - "False"
          - "TypeError"
          - "None"
        answer: "True"
        explanation: "Python considers numeric values equal regardless of type (int vs float)."

      - id: comp003
        difficulty: easy
        question: What is the output of `print(3 != '3')`?
        language: python
        code: "print(3 != '3')"
        options:
          - "True"
          - "False"
          - "TypeError"
          - "None"
        answer: "True"
        explanation: "Different types (int vs str) are not equal in Python."

      - id: comp004
        difficulty: medium
        question: What does `print(10 <= 5 or 3 > 2)` return?
        language: python
        code: "print(10 <= 5 or 3 > 2)"
        options:
          - "True"
          - "False"
          - "SyntaxError"
          - "None"
        answer: "True"
        explanation: "The second condition (3 > 2) is True, making the entire OR expression True."

      - id: log002
        difficulty: medium
        question: What is the output of `print(not (True and False))`?
        language: python
        code: "print(not (True and False))"
        options:
          - "True"
          - "False"
          - "None"
          - "Error"
        answer: "True"
        explanation: "Inner expression (True and False) evaluates to False, then NOT False becomes True."

      - id: log003
        difficulty: hard
        question: What does `print(False or not True and True)` evaluate to?
        language: python
        code: "print(False or not True and True)"
        options:
          - "True"
          - "False"
          - "None"
          - "Error"
        answer: "False"
        explanation: "Operator precedence: NOT first (not True=False), then AND (False and True=False), then OR (False or False=False)."

      - id: assign002
        difficulty: easy
        question: What is the value of `x` after `x = 5; x **= 3`?
        language: python
        code: |
          x = 5
          x **= 3
        options:
          - "8"
          - "15"
          - "125"
          - "Error"
        answer: "125"
        explanation: "Exponentiation assignment: x = x ** 3 → 5^3 = 125."

      - id: assign003
        difficulty: easy
        question: What does `x = 10; x %= 3; print(x)` output?
        language: python
        code: |
          x = 10
          x %= 3
          print(x)
        options:
          - "1"
          - "3"
          - "0"
          - "10"
        answer: "1"
        explanation: "Modulus assignment: x = x % 3 → remainder of 10/3 is 1."

      - id: identity001
        difficulty: medium
        question: What is the output of `print(5 is 5.0)`?
        language: python
        code: "print(5 is 5.0)"
        options:
          - "True"
          - "False"
          - "Error"
        answer: "False"
        explanation: "Different memory objects despite equal value (int vs float)."

      - id: identity002
        difficulty: medium
        question: What does `a = [1, 2]; b = a; print(a is b)` return?
        language: python
        code: |
          a = [1, 2]
          b = a
          print(a is b)
        options:
          - "True"
          - "False"
          - "None"
        answer: "True"
        explanation: "b references the same list object as a (same memory location)."

      - id: memb002
        difficulty: easy
        question: What does `print('ell' in 'hello')` output?
        language: python
        code: "print('ell' in 'hello')"
        options:
          - "True"
          - "False"
          - "Error"
        answer: "True"
        explanation: "Membership operator checks for substring presence."

      - id: memb003
        difficulty: easy
        question: What is the result of `print(3 not in [1, 2, 4])`?
        language: python
        code: "print(3 not in [1, 2, 4])"
        options:
          - "True"
          - "False"
          - "Error"
        answer: "True"
        explanation: "3 is not present in the list, so 'not in' returns True."

      - id: bit001
        difficulty: hard
        question: What is the output of `print(5 & 3)`?
        language: python
        code: "print(5 & 3)"
        options:
          - "7"
          - "1"
          - "0"
          - "15"
        answer: "1"
        explanation: "Bitwise AND: 0101 (5) & 0011 (3) = 0001 (1)."

      - id: bit002
        difficulty: medium
        question: What does `print(10 << 2)` return?
        language: python
        code: "print(10 << 2)"
        options:
          - "20"
          - "40"
          - "5"
          - "12"
        answer: "40"
        explanation: "Left shift: 10 * 2^2 = 40 (binary 1010 shifted left becomes 101000)."

      - id: prec001
        difficulty: hard
        question: What is the result of `print(2 + 3 * 4 ** 2)`?
        language: python
        code: "print(2 + 3 * 4 ** 2)"
        options:
          - "80"
          - "50"
          - "20"
          - "98"
        answer: "50"
        explanation: "Order: exponentiation (4**2=16), then multiplication (3*16=48), then addition (2+48=50)."

      - id: prec002
        difficulty: medium
        question: What does `print((2 + 3) * 4 ** 2)` output?
        language: python
        code: "print((2 + 3) * 4 ** 2)"
        options:
          - "80"
          - "100"
          - "400"
          - "144"
        answer: "80"
        explanation: "Parentheses first (2+3=5), then exponent (4^2=16), then multiplication (5*16=80)."

      - id: tricky001
        difficulty: medium
        question: What is the output of `print(True + False + 10)`?
        language: python
        code: "print(True + False + 10)"
        options:
          - "11"
          - "10"
          - "True"
          - "Error"
        answer: "11"
        explanation: "Boolean values are subclass of int (True=1, False=0), so 1 + 0 + 10 = 11."

      - id: tricky002
        difficulty: medium
        question: What does `print(10 < 9 < 8)` return?
        language: python
        code: "print(10 < 9 < 8)"
        options:
          - "True"
          - "False"
          - "Error"
        answer: "False"
        explanation: "Chained comparison: equivalent to (10 < 9) and (9 < 8), both False."

      - id: arith001
        difficulty: easy
        question: What is the output of the following Python code?
        language: python
        code: |
          x = 10
          y = 5
          x = x + y
          y = x - y
          x = x - y
          print(x, y)
        options:
          - "5 0"
          - "5 -5"
          - "10 5"
          - "5 10"
        answer: "5 10"
        explanation: This code swaps the values of x and y without using a temporary variable.

      - id: arith002
        difficulty: medium
        question: What is the output of the following expression?
        language: python
        code: "2 ** 3 + 4 // 2 - 1"
        options:
          - "8"
          - "9"
          - "10"
          - "11"
        answer: "9"
        explanation: The expression evaluates as (8) + (2) - 1 = 9 due to operator precedence.

      - id: arith003
        difficulty: easy
        question: What is the output of the following expression?
        language: python
        code: |
          x = 10
          y = 5
          print(x % y)
        options:
          - "2"
          - "5"
          - "0"
          - "1"
        answer: "0"
        explanation: The modulus operator returns the remainder of 10 divided by 5, which is 0.

      - id: comp001
        difficulty: easy
        question: What is the output of the following Python code?
        language: python
        code: |
          x = 5
          y = 10
          result = x > 3 or y < 5
          print(result)
        options:
          - "True"
          - "False"
          - "SyntaxError"
          - "None of these"
        answer: "True"
        explanation: The expression evaluates to True because x > 3 is True (even though y < 5 is False).

      - id: log001
        difficulty: medium
        question: What is the difference between 'and' and 'or' operators in Python?
        language: python
        code: null
        options:
          - "and returns True if both operands are True and or returns True if either operand is True"
          - "and returns True if either operand is True and or returns True if both operands are True"
          - "and returns False if both operands are False and or returns False if either operand is False"
          - "both A and C are correct"
        answer: "both A and C are correct"
        explanation: The 'and' operator requires both conditions to be True, while 'or' requires at least one to be True.

      - id: assign001
        difficulty: easy
        question: What is the output of x = 10; x //= 3?
        language: python
        code: "x = 10; x //= 3"
        options:
          - "3"
          - "3.33"
          - "3.5"
          - "4"
        answer: "3"
        explanation: The floor division operator // returns the largest integer less than or equal to the division result.

      - id: memb001
        difficulty: easy
        question: What is the output of the following Python code?
        language: python
        code: |
          num = 4
          result = num in [1, 3, 4]
          print(result)
        options:
          - "True"
          - "False"
          - "None"
          - "Error"
        answer: "True"
        explanation: The 'in' operator checks for membership and returns True since 4 is in the list.

  - topic: variables
    questions:
      - id: var001
        difficulty: easy
        question: What is a variable in Python?
        language: python
        code: null
        options:
          - "A reserved word in Python"
          - "A placeholder for storing data values"
          - "A function that prints data"
          - "A built-in library in Python"
        answer: "A placeholder for storing data values"
        explanation: A variable acts as a container to store data values in memory.

      - id: var002
        difficulty: easy
        question: Which statement best describes a variable in Python?
        language: python
        options:
          - "A variable can hold multiple values at once."
          - "A variable must be declared with a data type."
          - "A variable is a name that refers to a value."
          - "A variable is used only in loops."
        answer: "A variable is a name that refers to a value."
        explanation: In Python, variables are simply names that reference objects in memory.

      - id: var003
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          x = 10
          print(x)
        options:
          - "10"
          - "x"
          - "Error"
          - "None"
        answer: "10"
        explanation: The code assigns 10 to x and then prints the value of x.

      - id: var004
        difficulty: medium
        question: Which of the following is not true about variables in Python?
        language: python
        options:
          - "Variables can be reassigned to different data types."
          - "Variables must start with a letter or an underscore."
          - "Variables are case-sensitive."
          - "Variables must be declared before use."
        answer: "Variables must be declared before use."
        explanation: Python variables don't need declaration; they're created when first assigned.

      - id: var005
        difficulty: medium
        question: What will be the output of the following code?
        language: python
        code: |
          x = 5
          y = x
          x = 7
          print(y)
        options:
          - "7"
          - "5"
          - "0"
          - "None"
        answer: "5"
        explanation: y gets the value of x (5) before x is changed to 7.

      - id: var006
        difficulty: easy
        question: Why is it important to use meaningful variable names?
        language: python
        options:
          - "It is required by the Python interpreter."
          - "It helps make the code more readable and maintainable."
          - "It increases the execution speed of the program."
          - "It is necessary for the code to run without errors."
        answer: "It helps make the code more readable and maintainable."
        explanation: Good variable names improve code understanding without affecting functionality.

      - id: var007
        difficulty: medium
        question: What will be the output of the following code?
        language: python
        code: |
          a = 1
          b = a
          a = a + 1
          print(a, b)
        options:
          - "1 1"
          - "2 1"
          - "1 2"
          - "2 2"
        answer: "2 1"
        explanation: b gets the original value of a (1), then a is incremented to 2.

      - id: var008
        difficulty: easy
        question: Which of the following is a valid variable name in Python?
        language: python
        options:
          - "2ndValue"
          - "value#2"
          - "_value2"
          - "value-2"
        answer: "_value2"
        explanation: Valid names start with letters/underscores and contain alphanumerics/underscores.

      - id: var009
        difficulty: easy
        question: Which of the following is a correct way to declare a variable in Python?
        language: python
        options:
          - "int x = 5"
          - "x = 5"
          - "declare x = 5"
          - "var x = 5"
        answer: "x = 5"
        explanation: Python uses dynamic typing - just assign with = operator.

      - id: var010
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          x = 5
          y = "Hello"
          print(x + y)
        options:
          - "5Hello"
          - "Hello5"
          - "TypeError"
          - "Hello 5"
        answer: "TypeError"
        explanation: Python cannot implicitly concatenate different types (int + str).

      - id: var011
        difficulty: easy
        question: Which of the following is not a valid variable name in Python?
        language: python
        options:
          - "my_var"
          - "_var"
          - "2var"
          - "var2"
        answer: "2var"
        explanation: Variable names cannot start with numbers.

      - id: var012
        difficulty: medium
        question: Which of the following statements is true about variable assignment in Python?
        language: python
        options:
          - "Variables must be declared before they are assigned a value."
          - "Variables are created when they are first assigned a value."
          - "Variable names must begin with a number."
          - "Python variables must be declared with a type."
        answer: "Variables are created when they are first assigned a value."
        explanation: Python variables come into existence at first assignment.

      - id: var013
        difficulty: easy
        question: What is the purpose of declaring a variable in Python?
        language: python
        options:
          - "To reserve memory space for the variable"
          - "To give the variable a name"
          - "To initialize the variable with a value"
          - "All of the above"
        answer: "All of the above"
        explanation: Variable declaration achieves all these purposes simultaneously.

      - id: dyn001
        difficulty: easy
        question: What is dynamic typing in Python?
        language: python
        code: null
        options:
          - "Variables must be declared with a fixed data type."
          - "Variables can change their type during runtime."
          - "Python enforces strict type checking at compile time."
          - "Variables cannot be reassigned."
        answer: "Variables can change their type during runtime."
        explanation: Python allows variables to hold values of any type and change types dynamically.

      - id: dyn002
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          x = 10
          x = "Hello"
          print(type(x))
        options:
          - "<class 'int'>"
          - "<class 'str'>"
          - "Error"
          - "None"
        answer: "<class 'str'>"
        explanation: Python allows reassigning `x` from an integer to a string (dynamic typing).

      - id: dyn003
        difficulty: medium
        question: Which of the following is true about Python's type system?
        language: python
        code: null
        options:
          - "Python is statically typed."
          - "Python variables must be declared with a type."
          - "Python checks types at runtime (dynamic typing)."
          - "Python does not allow reassigning variables."
        answer: "Python checks types at runtime (dynamic typing)."
        explanation: Python resolves types during execution, not at compile time.

      - id: dyn004
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          x = None
          print(x is None)
        options:
          - "True"
          - "False"
          - "Error"
          - "None"
        answer: "True"
        explanation: "`None` is a singleton in Python, and `is` checks for identity."

      - id: dyn005
        difficulty: easy
        question: What does `None` represent in Python?
        language: python
        code: null
        options:
          - "A zero value"
          - "An empty string"
          - "The absence of a value"
          - "A placeholder for future use"
        answer: "The absence of a value"
        explanation: "`None` signifies <b>no value</b> or <b>null</b> in Python."

      - id: dyn006
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          def foo():
              pass
          print(foo())
        options:
          - "None"
          - "Error"
          - "0"
          - "pass"
        answer: "None"
        explanation: A function without a `return` statement implicitly returns `None`.

      - id: dyn007
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          x = [None, 1, "two"]
          print(type(x[0]))
        options:
          - "<class 'NoneType'>"
          - "<class 'int'>"
          - "<class 'str'>"
          - "Error"
        answer: "<class 'NoneType'>"
        explanation: "`None` has its own type, `NoneType`."

      - id: dyn008
        difficulty: medium
        question: How do you check if a variable is `None` in Python?
        language: python
        code: null
        options:
          - "if x == None:"
          - "if x is None:"
          - "if x = None:"
          - "if None in x:"
        answer: "if x is None:"
        explanation: "`is` is preferred over `==` for `None` checks (identity vs. equality)."

      - id: dyn009
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          x = None
          y = None
          print(x == y, x is y)
        options:
          - "True True"
          - "False False"
          - "True False"
          - "Error"
        answer: "True True"
        explanation: "`None == None` is `True`, and `None is None` is also `True` (same object)."

      - id: dyn010
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          def bar():
              return None
          print(bar() is None)
        options:
          - "True"
          - "False"
          - "Error"
          - "None"
        answer: "True"
        explanation: Explicitly returning `None` is the same as no `return` statement.

      - id: dyn011
        difficulty: easy
        question: Which of the following is a valid use of `None`?
        language: python
        code: null
        options:
          - "As a default function argument"
          - "To represent an uninitialized variable"
          - "To check if a key exists in a dictionary"
          - "All of the above"
        answer: "All of the above"
        explanation: "`None` is commonly used for all these purposes."

      - id: dyn012
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          x = "Hello"
          x = None
          print(x)
        options:
          - "Hello"
          - "None"
          - "Error"
          - "null"
        answer: "None"
        explanation: "`x` is reassigned to `None`, which is printed."

  - topic: oop-abstraction
    questions:
      - id: abs001
        difficulty: easy
        question: What is the primary purpose of abstraction in OOP?
        language: python
        code: null
        options:
          - "To hide implementation details and show only essential features"
          - "To allow multiple inheritance in Python"
          - "To enforce strict type checking"
          - "To optimize code performance"
        answer: "To hide implementation details and show only essential features"
        explanation: Abstraction focuses on exposing only necessary features while hiding complex implementation details.

      - id: abs002
        difficulty: medium
        question: How is abstraction typically achieved in Python?
        language: python
        code: null
        options:
          - "Using private methods with `__` prefix"
          - "Using abstract base classes (ABC) and `@abstractmethod`"
          - "Through function decorators only"
          - "By overloading operators"
        answer: "Using abstract base classes (ABC) and `@abstractmethod`"
        explanation: Python uses the `abc` module and `@abstractmethod` decorator to enforce abstraction by requiring subclasses to implement specific methods.

      - id: abs003
        difficulty: easy
        question: What will happen if a subclass doesn't implement an abstract method?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Animal(ABC):
              @abstractmethod
              def sound(self):
                  pass
          
          class Dog(Animal):
              pass
          obj = Dog()
        options:
          - "The code will run without errors"
          - "TypeError at class definition"
          - "TypeError at instantiation"
          - "The method will inherit the parent's implementation"
        answer: "TypeError at instantiation"
        explanation: Python raises a `TypeError` when you try to instantiate a subclass that doesn't implement all abstract methods.

      - id: abs004
        difficulty: medium
        question: Which module is required to create abstract classes in Python?
        language: python
        code: null
        options:
          - "`abstract`"
          - "`abc`"
          - "`oop`"
          - "`abstractmethod` only (no module needed)"
        answer: "`abc`"
        explanation: The `abc` module provides the `ABC` metaclass and `@abstractmethod` decorator for creating abstract classes.

      - id: abs005
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Shape(ABC):
              @abstractmethod
              def area(self):
                  pass
          
          class Square(Shape):
              def __init__(self, side):
                  self.side = side
              def area(self):
                  return self.side ** 2
          
          s = Square(4)
          print(s.area())
        options:
          - "0"
          - "16"
          - "TypeError (Shape cannot be instantiated)"
          - "Error (Square doesn't implement `area()`)"
        answer: "16"
        explanation: Since `Square` properly implements the abstract `area()` method, it can be instantiated, and the calculation works correctly.

      - id: abs006
        difficulty: medium
        question: Which of the following is TRUE about abstraction in Python?
        language: python
        code: null
        options:
          - "Abstract methods can have implementations in the parent class"
          - "A class with at least one abstract method can be instantiated"
          - "Abstract classes must inherit from `object`"
          - "Abstract methods can be declared without the `abc` module"
        answer: "Abstract methods can have implementations in the parent class"
        explanation: Abstract methods in Python can have implementations, but subclasses must still override them. The `@abstractmethod` decorator marks them as requiring override.

      - id: abs007
        difficulty: easy
        question: What does the `@abstractmethod` decorator do?
        language: python
        code: null
        options:
          - "Prevents a method from being called"
          - "Marks a method as requiring implementation in subclasses"
          - "Makes a method private"
          - "Optimizes method execution speed"
        answer: "Marks a method as requiring implementation in subclasses"
        explanation: The `@abstractmethod` decorator enforces that concrete subclasses must implement the decorated method.

      - id: abst001
        difficulty: easy
        question: What is abstraction in object-oriented programming?
        options:
          - "Hiding the internal implementation and showing only the necessary features"
          - "Creating private variables"
          - "Restricting access using access modifiers"
          - "Writing multiple methods with the same name"
        answer: "Hiding the internal implementation and showing only the necessary features"
        explanation: Abstraction is the concept of hiding complex implementation details and showing only the essential features to the user.

      - id: abst002
        difficulty: medium
        question: Which module in Python provides the base class for creating abstract classes?
        options:
          - "abc"
          - "abstract"
          - "base"
          - "oop"
        answer: "abc"
        explanation: The `abc` module in Python provides infrastructure for defining Abstract Base Classes.

      - id: abst003
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          from abc import ABC, abstractmethod

          class Shape(ABC):
              @abstractmethod
              def area(self):
                  pass

          class Circle(Shape):
              def area(self):
                  return 3.14 * 4 * 4

          c = Circle()
          print(c.area())
        options:
          - "50.24"
          - "Error: Can't instantiate abstract class"
          - "None"
          - "8"
        answer: "50.24"
        explanation: Since the `Circle` class implements the abstract method `area`, it can be instantiated and will return the calculated area.

      - id: abst004
        difficulty: easy
        question: What will happen if you try to instantiate an abstract class with an unimplemented abstract method?
        options:
          - "It will raise a TypeError"
          - "It will return None"
          - "It will call the method with default implementation"
          - "It will execute without any error"
        answer: "It will raise a TypeError"
        explanation: Python will raise a `TypeError` if you attempt to instantiate an abstract class that has unimplemented abstract methods.

      - id: abst005
        difficulty: medium
        question: Why do we use abstract base classes in Python?
        options:
          - "To enforce certain methods in subclasses"
          - "To allow direct instantiation"
          - "To reduce memory usage"
          - "To avoid using constructors"
        answer: "To enforce certain methods in subclasses"
        explanation: Abstract base classes are used to define a common interface and enforce that derived classes implement specific methods.
        
      - id: abs008
        difficulty: medium
        question: What is the output of this code?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Database(ABC):
              @abstractmethod
              def connect(self):
                  print("Default connection logic")
          
          class MySQL(Database):
              def connect(self):
                  super().connect()
                  print("MySQL connection")
          
          db = MySQL()
          db.connect()
        options:
          - "`MySQL connection`"
          - "`Default connection logic` followed by `MySQL connection`"
          - "TypeError (cannot instantiate abstract class)"
          - "Error: `super()` misuse"
        answer: "`Default connection logic` followed by `MySQL connection`"
        explanation: "Abstract methods CAN have implementations in Python. The subclass invokes the parent's implementation via `super()`."

      - id: abs009
        difficulty: hard
        question: Why does this code fail?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Logger(ABC):
              @abstractmethod
              def log(self, message):
                  pass
          
              @abstractmethod
              def close(self):
                  pass
          
          class FileLogger(Logger):
              def log(self, message):
                  print(f"Log: {message}")
          
          logger = FileLogger()  # Error occurs here
        options:
          - "Missing `close()` implementation in `FileLogger`"
          - "Abstract methods cannot have parameters like `message`"
          - "`FileLogger` must inherit from `object` first"
          - "`@abstractmethod` cannot be used twice"
        answer: "Missing `close()` implementation in `FileLogger`"
        explanation: "Subclasses must implement ALL abstract methods. Here, `close()` is missing."

      - id: abs010
        difficulty: medium
        question: What does this code demonstrate about abstraction?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class PaymentGateway(ABC):
              @abstractmethod
              def process_payment(self, amount):
                  pass
          
              def receipt(self, amount):
                  print(f"Receipt for ${amount}")
          
          class PayPal(PaymentGateway):
              def process_payment(self, amount):
                  print(f"Processing ${amount} via PayPal")
          
          payment = PayPal()
          payment.process_payment(100)
          payment.receipt(100)
        options:
          - "Abstract classes can have both abstract and concrete methods"
          - "`receipt()` must also be abstract"
          - "Subclasses cannot use parent's concrete methods"
          - "Abstract methods must return a value"
        answer: "Abstract classes can have both abstract and concrete methods"
        explanation: "The `receipt()` method is fully implemented in the abstract class and shared by all subclasses."

      - id: abs011
        difficulty: hard
        question: What is the key problem in this design?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class Vehicle(ABC):
              @abstractmethod
              def start_engine(self):
                  pass
          
              @abstractmethod
              def stop_engine(self):
                  pass
          
          class Bicycle(Vehicle):
              def start_engine(self):
                  raise NotImplementedError("Bicycles have no engine!")
          
              def stop_engine(self):
                  raise NotImplementedError("Bicycles have no engine!")
        options:
          - "Violates Liskov Substitution Principle (Bicycle isn't a valid Vehicle)"
          - "`NotImplementedError` should be replaced with `pass`"
          - "Abstract methods cannot raise exceptions"
          - "Missing `@abstractmethod` decorator in `Bicycle`"
        answer: "Violates Liskov Substitution Principle (Bicycle isn't a valid Vehicle)"
        explanation: "Forcing `Bicycle` to implement engine methods indicates a flawed abstraction hierarchy."

      - id: abs012
        difficulty: easy
        question: What is the purpose of `ABC.register()` here?
        language: python
        code: |
          from abc import ABC
          class Duck:
              def quack(self):
                  print("Quack!")
          
          class Bird(ABC):
              @classmethod
              def __subclasshook__(cls, subclass):
                  return hasattr(subclass, 'quack')
          
          Bird.register(Duck)
          duck = Duck()
          print(isinstance(duck, Bird))  # Output: True
        options:
          - "Ensures `Duck` implements all abstract methods of `Bird`"
          - "Dynamically registers `Duck` as a virtual subclass of `Bird`"
          - "Prevents `Duck` from being instantiated"
          - "Creates a strict inheritance relationship"
        answer: "Dynamically registers `Duck` as a virtual subclass of `Bird`"
        explanation: "`register()` allows non-inheriting classes to be treated as subclasses if they meet the interface (duck typing)."

      - id: abs013
        difficulty: medium
        question: What makes this code a proper abstraction?
        language: python
        code: |
          from abc import ABC, abstractmethod
          class DataExporter(ABC):
              @abstractmethod
              def export(self, data):
                  pass
          
              def validate(self, data):
                  return isinstance(data, list)
          
          class CSVExporter(DataExporter):
              def export(self, data):
                  if self.validate(data):
                      print(f"Exporting {len(data)} rows to CSV")
                  else:
                      raise ValueError("Invalid data format")
          
          exporter = CSVExporter()
          exporter.export([1, 2, 3])
        options:
          - "It hides validation logic inside the abstract class"
          - "It forces subclasses to implement `export()` but shares `validate()`"
          - "It uses `ABC` to prevent instantiation"
          - "All of the above"
        answer: "All of the above"
        explanation: "This demonstrates encapsulation (validation hiding), method enforcement (`export()`), and reusable shared logic (`validate()`)."

  - topic: oop-encapsulation
    questions:
      - id: encap001
        difficulty: easy
        question: What is encapsulation in Python OOP?
        options:
          - "A way to hide internal implementation details and expose only necessary features"
          - "A method to combine multiple functions into one"
          - "A technique to make code run faster"
          - "A way to remove unused variables"
        answer: "A way to hide internal implementation details and expose only necessary features"
        explanation: Encapsulation helps in restricting access to certain components and prevents unintended modifications.

      - id: encap002
        difficulty: easy
        question: How do you make an attribute private in Python?
        options:
          - "By using the `private` keyword"
          - "By prefixing the attribute name with a single underscore `_`"
          - "By prefixing the attribute name with double underscores `__`"
          - "By using the `hidden` keyword"
        answer: "By prefixing the attribute name with double underscores `__`"
        explanation: In Python, double underscores `__` make an attribute name-mangled, restricting direct access.

      - id: encap003
        difficulty: easy
        question: What is the purpose of getter and setter methods in encapsulation?
        options:
          - "To directly modify private attributes"
          - "To control access and modification of private attributes"
          - "To delete unused variables"
          - "To improve code execution speed"
        answer: "To control access and modification of private attributes"
        explanation: Getters and setters allow controlled access to private attributes, enabling validation or modification checks.

      - id: encap004
        difficulty: medium
        question: Which of the following is true about name mangling in Python?
        options:
          - "It makes an attribute completely inaccessible"
          - "It renames the attribute to `_ClassName__attribute`"
          - "It deletes the attribute after use"
          - "It is done using the `@mangle` decorator"
        answer: "It renames the attribute to `_ClassName__attribute`"
        explanation: Name mangling changes the attribute name to `_ClassName__attribute` to avoid accidental access.

      - id: encap005
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class BankAccount:
              def __init__(self):
                  self.__balance = 100

              def get_balance(self):
                  return self.__balance

          acc = BankAccount()
          print(acc.__balance)
        options:
          - "100"
          - "Error: AttributeError (private attribute access)"
          - "None"
          - "0"
        answer: "Error: AttributeError (private attribute access)"
        explanation: Double underscores make `__balance` private, so direct access outside the class raises an error.

      - id: encap006
        difficulty: easy
        question: What is the correct way to access a private attribute from outside its class?
        options:
          - "By using the `public` keyword"
          - "By calling `object._attribute`"
          - "By using a getter method"
          - "By using `object.__attribute`"
        answer: "By using a getter method"
        explanation: The safest way is to use a getter method (e.g., `get_balance()`) instead of direct access.

      - id: encap007
        difficulty: medium
        question: Which keyword is used to define a read-only property in Python?
        options:
          - "`@readonly`"
          - "`@property`"
          - "`@getter`"
          - "`@final`"
        answer: "`@property`"
        explanation: The `@property` decorator allows defining a method as a read-only attribute.

      - id: encap008
        difficulty: easy
        question: What is the purpose of the single underscore `_` before a variable name?
        options:
          - "It makes the variable private"
          - "It indicates that the variable is for internal use (convention)"
          - "It makes the variable global"
          - "It prevents the variable from being modified"
        answer: "It indicates that the variable is for internal use (convention)."
        explanation: A single underscore is a naming convention to suggest that a variable is for internal use (not enforced by Python). It should be accessed only within the class or its subclasses.

      - id: encap009
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Student:
              def __init__(self):
                  self.__name = "Alice"
          
          s = Student()
          print(s.__name)
        options:
          - "Alice"
          - "None"
          - "Error: AttributeError (private attribute access)"
          - "'' (empty string)"
        answer: "Error: AttributeError (private attribute access)"
        explanation: Private attributes (prefixed with `__`) cannot be accessed directly outside the class.

      - id: encap010
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Student:
              def __init__(self):
                  self.__name = "Alice"
              
              def get_name(self):
                  return self.__name
          
          s = Student()
          print(s.get_name())
        options:
          - "Alice"
          - "Error: Method not defined"
          - "None"
          - "'' (empty string)"
        answer: "Alice"
        explanation: The `get_name()` method provides controlled access to the private `__name` attribute.

      - id: encap011
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Temperature:
              def __init__(self):
                  self.__celsius = 30
              
              def get_fahrenheit(self):
                  return (self.__celsius * 9/5) + 32
          
          t = Temperature()
          print(t.get_fahrenheit())
        options:
          - "30"
          - "86"
          - "Error: AttributeError"
          - "None"
        answer: "86"
        explanation: The private `__celsius` is used internally to compute Fahrenheit (30°C = 86°F).

      - id: encap012
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Account:
              def __init__(self):
                  self.__balance = 0
              
              def deposit(self, amount):
                  self.__balance += amount
              
              def withdraw(self, amount):
                  if amount <= self.__balance:
                      self.__balance -= amount
                  else:
                      print("Insufficient funds!")
              
              def get_balance(self):
                  return self.__balance
          
          acc = Account()
          acc.deposit(100)
          acc.withdraw(30)
          print(acc.get_balance())
        options:
          - "0"
          - "70"
          - "100"
          - "Error"
        answer: "70"
        explanation: The private `__balance` is modified only via methods (`deposit()` and `withdraw()`).

      - id: encap013
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Person:
              def __init__(self):
                  self.__age = 25
              
              @property
              def age(self):
                  return self.__age
              
              @age.setter
              def age(self, value):
                  if value > 0:
                      self.__age = value
                  else:
                      print("Invalid age!")
          
          p = Person()
          p.age = -5
          print(p.age)
        options:
          - "-5"
          - "25"
          - "0"
          - "Invalid age!"
        answer: "25"
        explanation: The setter rejects negative values, so `__age` remains unchanged (25).

      - id: encap014
        difficulty: medium
        question: What is the output of the following code?
        language: python
        code: |
          class Car:
              def __init__(self):
                  self.__speed = 0
              
              def accelerate(self):
                  self.__speed += 10
              
              def brake(self):
                  self.__speed = max(0, self.__speed - 10)
              
              def get_speed(self):
                  return self.__speed
          
          c = Car()
          c.accelerate()  # Typo in method name
          print(c.get_speed())
        options:
          - "0"
          - "10"
          - "Error: AttributeError"
          - "Error: Method not found"
        answer: "Error: Method not found"
        explanation: The typo `accelerate()` → `accelerate()` causes an `AttributeError`.

      - id: encap015
        difficulty: hard
        question: What is the output of the following code?
        language: python
        code: |
          class Secret:
              def __init__(self):
                  self.__key = "1234"
              
              def _get_key(self):
                  return self.__key[::-1]  # Reversed
          
          s = Secret()
          print(s._get_key())
        options:
          - "1234"
          - "4321"
          - "Error: Private method access"
          - "None"
        answer: "4321"
        explanation: Single underscore `_get_key()` is

  - topic: oop-inheritance
    questions:
      - id: inh001
        difficulty: easy
        question: What is the output of the following code?
        language: python
        code: |
          class Animal:
              def speak(self):
                  print("Animal speaks")

          class Dog(Animal):
              pass

          d = Dog()
          d.speak()
        options:
          - Animal speaks
          - Dog speaks
          - "Error: **speak()** not defined"
          - Nothing
        answer: Animal speaks
        explanation: Dog inherits the `speak()` method from Animal.

      - id: py-inh-002
        difficulty: medium
        question: |
          What is the output of the following Python code?
        language: python
        code: |
          class Parent:
              def greet(self):
                  print("Hello from Parent")

          class Child(Parent):
              def greet(self):
                  print("Hello from Child")
                  Parent.greet(self)     
                  super().greet()         

          obj = Child()
          obj.greet()
        options:
          - |
            Hello from Child
            Hello from Parent
            Hello from Parent
          - |
            Hello from Parent
            Hello from Child
            Hello from Parent
          - |
            Hello from Child
            Hello from Child
            Hello from Parent
          - |
            Hello from Parent
            Hello from Parent
            Hello from Child
        answer: |
          Hello from Child
          Hello from Parent
          Hello from Parent
        explanation: |
          The `Child.greet()` method prints "Hello from Child", then explicitly calls `Parent.greet(self)` and `super().greet()`, both of which call the `Parent` class's `greet()` method, resulting in "Hello from Parent" printed twice.

      - id: py-inh-001
        difficulty: easy
        question: What is the main purpose of inheritance in Python?
        options:
          - To create multiple objects of a class
          - To reuse code and extend functionality
          - To define private methods in a class
          - To create a new programming paradigm
        answer: To reuse code and extend functionality
        explanation: Inheritance allows code reuse and method overriding in child classes.
      - id: py002
        difficulty: easy
        question: Which of the following is the correct syntax for inheritance in Python?
        options:
          - "class Child inherits Parent:"
          - "class Child(Parent):"
          - "class Parent -> Child:"
          - "class Parent(Child):"
        answer: "class Child(Parent):"
        explanation: In Python, a child class is defined using the syntax `class Child(Parent):`, where `Child` inherits from `Parent`.
      - id: inh002
        difficulty: easy
        question: What is the output of the following code?
        code: |
          class Parent:
              def __init__(self):
                  print("Parent constructor")

          class Child(Parent):
              def __init__(self):
                  print("Child constructor")

          c = Child()
        options:
          - Parent constructor
          - Child constructor
          - Parent constructor Child constructor
          - Error
        answer: Child constructor
        explanation: The `Child` constructor overrides the `Parent` constructor.

      - id: inh003
        difficulty: medium
        question: What is the output of the following code?
        code: |
          class Parent:
              def show(self):
                  print("Parent")

          class Child(Parent):
              def show(self):
                  print("Child")

          obj = Child()
          obj.show()
        options:
          - Parent
          - Child
          - Parent Child
          - Error
        answer: Child

      - id: py-inh-001
        difficulty: easy
        question: What is the primary purpose of inheritance in Python?
        options:
          - To improve memory efficiency
          - To hide implementation details
          - To enable code reusability
          - To reduce program complexity
        answer: To enable code reusability
        explanation: Inheritance helps avoid code duplication by allowing child classes to reuse methods and properties of parent classes.

      - id: py-inh-002
        difficulty: easy
        question: Which syntax correctly defines a class `Child` inheriting from `Parent`?
        options:
          - class Child extends Parent:
          - class Child(Parent):
          - class Child inherits Parent:
          - class Child : Parent
        answer: "class Child(Parent):"
        explanation: In Python, inheritance is denoted by placing the parent class name in parentheses after the child class name.

      - id: py-inh-003
        difficulty: medium
        question: What is the output of the following code?
        code: |
          class Parent:
              def greet(self):
                  print("Hello from Parent!")
          
          class Child(Parent):
              def greet(self):
                  print("Hello from Child!")

          obj = Child()
          obj.greet()
        options:
          - Hello from Parent!
          - Hello from Child!
          - Error
          - No output
        answer: Hello from Child!
        explanation: The `greet` method is overridden in the `Child` class, so that version is called.

      - id: py-inh-004
        difficulty: medium
        question: What does the `super()` function do?
        options:
          - Returns the base class instance
          - Calls a method from a sibling class
          - Calls a method from the parent class
          - Creates a new subclass
        answer: Calls a method from the parent class
        explanation: "`super()` is used to call methods from the parent class, especially in method overrides"

      - id: py-inh-005
        difficulty: hard
        question: Which type of inheritance is NOT supported in Python?
        options:
          - Single
          - Multiple
          - Cascading
          - Multilevel
        answer: Cascading
        explanation: Python supports single, multiple, and multilevel inheritance, but "cascading" is not a recognized inheritance type.

      - id: py-inh-006
        difficulty: medium
        question: "In multiple inheritance, the method resolution order (MRO) follows:"
        options:
          - Depth-first search
          - Breadth-first search
          - C3 linearization
          - Random order
        answer: C3 linearization
        explanation: Python uses C3 linearization to determine the order in which classes are searched when executing a method.

      - id: py-inh-007
        difficulty: hard
        question: How do you explicitly call a parent class method from a child class?
        options:
          - Parent.method(self)
          - self.parent_method()
          - super().method()
          - Both A and C
        answer: Both A and C
        explanation: You can call a parent method using either `Parent.method(self)` or `super().method()`.

      - id: py-inh-008
        difficulty: hard
        question: Which statement about private members (e.g., `__var`) in inheritance is true?
        options:
          - They are directly accessible in subclasses
          - They are inaccessible due to name mangling
          - They can be accessed using `super()`
          - They are inherited without name mangling
        answer: They are inaccessible due to name mangling
        explanation: Private members with double underscores are name-mangled and not directly accessible from subclasses.

      - id: py-inh-009
        difficulty: medium
        question: What does `isinstance(child_obj, Parent)` return?
        options:
          - True
          - False
          - TypeError
          - None
        answer: True
        explanation: If `child_obj` is an instance of a class derived from `Parent`, `isinstance` will return `True`.

      - id: py-inh-010
        difficulty: hard
        question: "Hybrid inheritance refers to:"
        options:
          - Combining multiple types of inheritance
          - Inheriting from two parent classes
          - Overriding all parent methods
          - Using interfaces only
        answer: Combining multiple types of inheritance
        explanation: Hybrid inheritance is a combination of more than one type of inheritance, like multiple and multilevel.
    resources:
    - name: Learn Inheritance in Python
      url: https://yasirbhutta.github.io/python/docs/oop-inheritance.html

  - topic: oop-polymorphism
    questions:
      - id: py011
        difficulty: medium
        question: What is polymorphism in Python?
        options:
          - Inheritance of attributes from a class
          - The ability of different classes to provide different implementations of the same method
          - The process of creating objects from a class
          - None of the above
        answer: The ability of different classes to provide different implementations of the same method
        explanation: Polymorphism allows methods to be defined in multiple classes with different implementations.
      - id: py012
        difficulty: medium
        question: Which function is used to determine the type of an object in Python?
        options:
          - type()
          - isinstance()
          - object()
          - None of the above
        answer: type()
        explanation: The `type()` function is used to determine the type of an object in Python.
    resources:
    - name: Learn Polymorphism in Python
      url: https://yasirbhutta.github.io/python/docs/oop-polymorphism.html

  - topic: strings
    questions:
      - id: py-str-001
        difficulty: easy
        question: What will be the output of the following code?
        code: |
          name = "Alice"
          print(name[1])
        options:
          - A
          - l
          - i
          - e
        answer: l
        explanation: Indexing in strings starts at 0, so `name[1]` gives the second character, which is 'l'.

      - id: py-str-002
        difficulty: easy
        question: Which method converts a string to all uppercase letters?
        options:
          - capitalize()
          - upper()
          - title()
          - swapcase()
        answer: upper()
        explanation: The `upper()` method converts all characters in a string to uppercase.

      - id: py-str-003
        difficulty: easy
        question: What does the `strip()` method do?
        options:
          - Removes only leading spaces
          - Removes only trailing spaces
          - Removes both leading and trailing spaces
          - Removes all spaces inside the string
        answer: Removes both leading and trailing spaces
        explanation: The `strip()` method removes whitespace from both ends of the string.

      - id: py-str-004
        difficulty: easy
        question: What is the output of the following code?
        code: |
          word = "HELLO"
          print(word.lower())
        options:
          - Hello
          - hello
          - HELLO
          - error
        answer: hello
        explanation: The `lower()` method converts all uppercase letters in a string to lowercase.

      - id: py-str-005
        difficulty: easy
        question: What is the output of this code?
        code: |
          text = "python"
          print(text.title())
        options:
          - Python
          - PYTHON
          - python
          - P y t h o n
        answer: Python

      - id: py-str-003
        difficulty: easy
        question: What does the `strip()` method do?
        options:
          - Removes only leading spaces
          - Removes only trailing spaces
          - Removes both leading and trailing spaces
          - Removes all spaces inside the string
        answer: Removes both leading and trailing spaces
        explanation: The `strip()` method removes whitespace from both ends of the string.

      - id: py-str-004
        difficulty: easy
        question: What is the output of the following code?
        code: |
          word = "HELLO"
          print(word.lower())
        options:
          - Hello
          - hello
          - HELLO
          - error
        answer: hello
        explanation: The `lower()` method converts all uppercase letters in a string to lowercase.

      - id: py-str-005
        difficulty: easy
        question: What is the output of the following code?
        code: |
          text = "python"
          print(text.title())
        options:
          - Python
          - PYTHON
          - python
          - P y t h o n
        answer: Python
        explanation: The `title()` method capitalizes the first letter of each word in the string.

      - id: py-str-001
        difficulty: easy
        question: What does the `split()` method return?
        options:
          - A single string
          - A tuple
          - A dictionary
          - A list of strings
        answer: A list of strings
        explanation: The `split()` method divides a string into a list based on a specified delimiter.

      - id: py-str-002
        difficulty: easy
        question: What will be the output of this code?
        code: |
          "apple,banana,grape".split(",")
        options:
          - "['apple', 'banana', 'grape']"
          - ('apple', 'banana', 'grape')
          - 'apple banana grape'
          - ['apple,banana,grape']
        answer: "['apple', 'banana', 'grape']"
        explanation: The `split(",")` method splits the string wherever it finds a comma and returns a list.

      - id: py-str-003
        difficulty: medium
        question: What does the `partition()` method return?
        options:
          - Only the substring before the separator
          - A list of split strings
          - A tuple of three parts
          - A dictionary of parts
        answer: A tuple of three parts
        explanation: "The artition() method splits a string into three parts: before the separator, the separator itself, and after."

      - id: py-str-004
        difficulty: easy
        question: Which method can be used to replace all occurrences of a substring with another substring?
        options:
          - change()
          - substitute()
          - switch()
          - replace()
        answer: replace()
        explanation: The `replace()` method is used to replace all occurrences of a specified substring.

      - id: py-str-005
        difficulty: medium
        question: What is the output of the following code?
        code: |
          "hello world".find("o")
        options:
          - 4
          - 5
          - 6
          - -1
        answer: 4
        explanation: The `find()` method returns the first index of the substring "o", which is 4.

    resources:
    - name: Learn String Methods & Formatting
      url: https://yasirbhutta.github.io/python/docs/strings.html

  - topic: lambda
    questions:
      - id: py-lambda-001
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          add_ten = lambda x: x + 10
          print(add_ten(5))
        options:
          - 15
          - 10
          - 5
          - 20
        answer: 15
        explanation: |
          The lambda function adds 10 to the given input. 5 + 10 = 15.

      - id: py-lambda-002
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          mul = lambda a, b: a * b
          print(mul(2, 4))
        options:
          - 6
          - 8
          - 4
          - 2
        answer: 8
        explanation: |
          The lambda function multiplies the two inputs: 2 * 4 = 8.

      - id: py-lambda-003
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          is_even = lambda x: x % 2 == 0
          print(is_even(6))
        options:
          - True
          - False
          - None
          - 0
        answer: True
        explanation: |
          6 is divisible by 2, so the lambda function returns True.

      - id: py-lambda-004
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          (lambda x, y: x + y)(6, 8)
        options:
          - 14
          - 48
          - 68
          - 86
        answer: 14
        explanation: |
          The lambda function adds 6 and 8, resulting in 14.

      - id: py-lambda-005
        difficulty: easy
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          result = (lambda x, y: x * y)(5, 3)
          print(result)
        options:
          - 15
          - 8
          - 5
          - 3
        answer: 15
        explanation: |
          The lambda function multiplies 5 and 3, resulting in 15.

      - id: py-lambda-006
        difficulty: hard
        language: python
        question: |
          What is the output of the following Python code?
        code: |
          multiply = lambda x, y: x * y
          mult = lambda x, y: multiply(x, y)
          result = mult(6, 2)
          print(result)
        options:
          - 8
          - 12
          - 6
          - 2
        answer: 12
        explanation: |
          The first lambda `multiply` multiplies two numbers. The second lambda `mult` calls the first, so 6 * 2 = 12.

    resources:
    - name: "Understanding Python Lambda Functions: A Comprehensive Guide"
      url: https://yasirbhutta.github.io/python/docs/lambda/