course: python
topics:

  - topic: loops-while
    questions:
      - id: while-fix-001
        difficulty: easy
        prompt: |
          Fix the syntax error in this while loop.
        code: |
          count = 0
          while count < 5
              print(count)
              count += 1
        hint: "Check the punctuation at the end of the while statement."
        issue: "Missing colon at the end of the while condition."
        solution: |
          count = 0
          while count < 5:
              print(count)
              count += 1

      - id: while-fix-002
        difficulty: easy
        prompt: |
          This loop will run infinitely. Fix it.
        code: |
          x = 1
          while x < 10:
              print(x)
        hint: "The loop variable is not being updated."
        issue: "Missing increment operation causes infinite loop."
        solution: |
          x = 1
          while x < 10:
              print(x)
              x += 1

      - id: while-fix-003
        difficulty: medium
        prompt: |
          Fix the logical error in this loop that prints even numbers.
        code: |
          num = 0
          while num <= 10:
              if num % 2 == 1:
                  print(num)
              num += 1
        hint: "The condition checks for odd numbers instead of even."
        issue: "The modulo condition checks for odd numbers (==1) when it should check for even numbers (==0)."
        solution: |
          num = 0
          while num <= 10:
              if num % 2 == 0:
                  print(num)
              num += 1

      - id: while-fix-004
        difficulty: medium
        prompt: |
          Fix the indentation error in this nested while loop.
        code: |
          i = 1
          while i <= 3:
              j = 1
          while j <= 3:
              print(i, j)
              j += 1
              i += 1
        hint: "The inner while loop should be indented inside the outer one."
        issue: "Improper indentation of the inner while loop."
        solution: |
          i = 1
          while i <= 3:
              j = 1
              while j <= 3:
                  print(i, j)
                  j += 1
              i += 1

      - id: while-fix-005
        difficulty: hard
        prompt: |
          This loop should print numbers 1 through 5 but has multiple issues. Fix them.
        code: |
          counter == 1
          while counter < 6
          print(counter)
          counter =+ 1
        hint: "Look for assignment vs comparison, missing colon, incorrect operator, and indentation."
        issue: "Multiple errors: assignment vs comparison (==), missing colon, incorrect increment operator (=+), and missing indentation."
        solution: |
          counter = 1
          while counter < 6:
              print(counter)
              counter += 1

      - id: while-fix-006
        difficulty: medium
        prompt: |
          Fix the loop that should exit when the user enters 'quit'.
        code: |
          while True:
              user_input = input("Enter something (or 'quit' to exit): ")
              if user_input = 'quit':
                  break
        hint: "Check the comparison operator in the if statement."
        issue: "Using assignment operator (=) instead of equality operator (==)."
        solution: |
          while True:
              user_input = input("Enter something (or 'quit' to exit): ")
              if user_input == 'quit':
                  break

  - topic: loops-for
    questions:
      - id: for-fix-001
        difficulty: easy
        prompt: |
          Fix the syntax error in this for loop.
        code: |
          fruits = ['apple', 'banana', 'cherry']
          for fruit in fruits
              print(fruit)
        hint: "Check the punctuation at the end of the for statement."
        issue: "Missing colon at the end of the for statement."
        solution: |
          fruits = ['apple', 'banana', 'cherry']
          for fruit in fruits:
              print(fruit)

      - id: for-fix-002
        difficulty: easy
        prompt: |
          Fix the infinite loop in this code.
        code: |
          numbers = [1, 2, 3]
          for i in range(len(numbers)):
              print(numbers[i])
              i += 2
        hint: "The loop variable in a for loop is automatically updated."
        issue: "Manually modifying the loop variable (i) doesn't affect the iteration."
        solution: |
          numbers = [1, 2, 3]
          for i in range(len(numbers)):
              print(numbers[i])

      - id: for-fix-003
        difficulty: medium
        prompt: |
          Fix the logic error in this loop that skips elements.
        code: |
          numbers = [10, 20, 30, 40, 50]
          for i in range(len(numbers)):
              if i % 2 == 0:
                  continue
              print(numbers[i])
        hint: "The code is printing elements at odd indices, not even ones."
        issue: "Condition is reversed - prints odd-indexed elements when it should print even-indexed."
        solution: |
          numbers = [10, 20, 30, 40, 50]
          for i in range(len(numbers)):
              if i % 2 != 0:
                  continue
              print(numbers[i])

      - id: for-fix-004
        difficulty: medium
        prompt: |
          Fix the NameError in this nested loop.
        code: |
          matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
          for row in matrix:
              for element in row:
                  total += element
          print(total)
        hint: "Variables need to be initialized before use."
        issue: "total variable is used but never initialized."
        solution: |
          matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
          total = 0
          for row in matrix:
              for element in row:
                  total += element
          print(total)

      - id: for-fix-005
        difficulty: hard
        prompt: |
          Fix the unintended behavior in this loop that modifies a list while iterating.
        code: |
          numbers = [1, 2, 3, 4, 5]
          for num in numbers:
              if num % 2 == 0:
                  numbers.remove(num)
          print(numbers)
        hint: "Modifying a list while iterating over it can cause unexpected behavior."
        issue: "Modifying a list during iteration can skip elements."
        solution: |
          numbers = [1, 2, 3, 4, 5]
          numbers_copy = numbers.copy()
          for num in numbers_copy:
              if num % 2 == 0:
                  numbers.remove(num)
          print(numbers)
          # Better alternative:
          # numbers = [num for num in numbers if num % 2 != 0]
          # print(numbers)

      - id: for-fix-006
        difficulty: medium
        prompt: |
          Fix the off-by-one error in this range-based loop.
        code: |
          for i in range(1, 10, 2):
              print(i)
          # Expected to print numbers 1 through 10
        hint: "Check the stop parameter of the range function."
        issue: "range(1, 10, 2) stops at 9, not 10."
        solution: |
          for i in range(1, 11, 2):
              print(i)

  - topic: tuples
    questions:
      - id: tuple-fix-001
        difficulty: easy
        prompt: |
          Fix the tuple creation error in this code.
        code: |
          colors = ('red', 'green' 'blue')
          print(colors)
        hint: "Tuples require commas between elements."
        issue: Missing comma between 'green' and 'blue' causes string concatenation.
        solution: |
          colors = ('red', 'green', 'blue')
          print(colors)

      - id: tuple-fix-002
        difficulty: medium
        prompt: |
          Fix the tuple modification attempt.
        code: |
          coordinates = (10, 20, 30)
          coordinates[1] = 25
          print(coordinates)
        hint: "Tuples are immutable - consider creating a new tuple."
        issue: Cannot modify tuple elements directly.
        solution: |
          coordinates = (10, 20, 30)
          new_coordinates = (coordinates[0], 25, coordinates[2])
          print(new_coordinates)

      - id: tuple-fix-003
        difficulty: medium
        prompt: |
          Fix the incorrect single-element tuple creation.
        code: |
          single = (5)
          print(type(single))
        hint: "Single-element tuples require a trailing comma."
        issue: Without comma, it's just an integer in parentheses.
        solution: |
          single = (5,)
          print(type(single))

      - id: tuple-fix-004
        difficulty: hard
        prompt: |
          Fix the tuple unpacking error.
        code: |
          point = (1, 2, 3)
          x, y = point
          print(x, y)
        hint: "Number of variables must match tuple length, or use extended unpacking."
        issue: Too many values to unpack (expected 2).
        solution: |
          point = (1, 2, 3)
          x, y, z = point
          print(x, y)
          # OR
          x, y, _ = point
          print(x, y)

      - id: tuple-fix-005
        difficulty: medium
        prompt: |
          Fix the incorrect tuple method usage.
        code: |
          numbers = (1, 2, 3)
          numbers.append(4)
          print(numbers)
        hint: "Tuples don't support append - consider alternatives."
        issue: Tuples are immutable and have no append method.
        solution: |
          numbers = (1, 2, 3)
          numbers = numbers + (4,)
          print(numbers)

      - id: tuple-fix-006
        difficulty: hard
        prompt: |
          Fix the slicing mistake to get the last two elements.
        code: |
          data = (10, 20, 30, 40)
          last_two = data[2:3]
          print(last_two)
        hint: "Slice end index is exclusive - need to go beyond the last element."
        issue: Current slice only gets element at index 2.
        solution: |
          data = (10, 20, 30, 40)
          last_two = data[-2:]
          print(last_two)

      - id: tuple-fix-007
        difficulty: easy
        prompt: |
          Fix the incorrect tuple comparison.
        code: |
          t1 = (1, 2)
          t2 = (1, 2, 3)
          result = t1 > t2
          print(result)
        hint: "Longer tuples are considered greater if preceding elements are equal."
        issue: Incorrect comparison operator for the intended check.
        solution: |
          t1 = (1, 2)
          t2 = (1, 2, 3)
          result = len(t1) > len(t2)  # Or whatever comparison was intended
          print(result)

  - topic: if-elif-else
    questions:
      - id: if-fix-001
        difficulty: easy
        prompt: |
          Fix the logical mistake in if-elif structure.
        code: |
          x = 7

          if x > 5:
              print("x is greater than 5")
          elif x > 0:
              print("x is positive")
        hint: " `elif` is only checked if the `if` condition fails."
        issue: The second condition won't run because the first is already true.
        solution: |
          x = 7

          if x > 5:
              print("x is greater than 5")
          if x > 0:
              print("x is positive")

      - id: if-fix-002
        difficulty: medium
        prompt: |
          Fix the infinite loop caused by a missing update in a while loop.
        code: |
          n = 10

          while n > 0:
              print(n)
        hint: The loop condition never changes.
        issue: Missing update to `n` causes an infinite loop.
        solution: |
          n = 10

          while n > 0:
              print(n)
              n -= 1

      - id: if-fix-003
        difficulty: medium
        prompt: |
          Fix the misuse of `continue` in a while loop that leads to an infinite loop.
        code: |
          i = 0

          while i < 5:
              if i == 2:
                  continue
              print(i)
              i += 1
        hint: Ensure the counter increments even when `continue` is used.
        issue: "`i` is never incremented when `i == 2`, causing infinite loop."
        solution: |
          i = 0

          while i < 5:
              if i == 2:
                  i += 1
                  continue
              print(i)
              i += 1

      - id: if-fix-004
        difficulty: easy
        prompt: |
          Simplify and correct the final condition in if-elif chain.
        code: |
          score = 75

          if score >= 90:
              print("A")
          elif score >= 80:
              print("B")
          elif score >= 70:
              print("C")
          elif score >= 60:
              print("D")
          elif score < 70:
              print("F")
        hint: Use `else` to catch all remaining cases.
        issue: The last condition is redundant.
        solution: |
          score = 75

          if score >= 90:
              print("A")
          elif score >= 80:
              print("B")
          elif score >= 70:
              print("C")
          elif score >= 60:
              print("D")
          else:
              print("F")

      - id: if-fix-005
        difficulty: easy
        prompt: |
          Identify and fix the syntax error caused by a missing colon.
        code: |
          if x > 5  # Missing colon here
            print("X is greater than 5")
        hint: All `if` statements must end with a colon.
        issue: Syntax error due to missing colon.
        solution: |
          if x > 5:
              print("X is greater than 5")

      - id: if-fix-006
        difficulty: easy
        prompt: |
          Fix the indentation error in the following loop.
        code: |
          for i in range(0, 11):
          if i % 2 == 0:
              print(i)
        hint: "`if` needs to be part of the `for` loop body."
        issue: Improper indentation of `if` statement.
        solution: |
          for i in range(0, 11):
              if i % 2 == 0:
                  print(i)

      - id: if-fix-007
        difficulty: easy
        prompt: |
          Add the missing colon in the if statement.
        code: |
          x = 10

          if x > 5
              print("x is greater than 5")
        hint: A colon is required after the condition.
        issue: Syntax error due to missing colon.
        solution: |
          x = 10

          if x > 5:
              print("x is greater than 5")

      - id: if-fix-008
        difficulty: easy
        prompt: |
          Fix the incorrect indentation in the else block.
        code: |
          y = -3

          if y > 0:
              print("y is positive")
              print("This is always printed")
          else:
          print("y is not positive")
        hint: Align all code blocks correctly under their headers.
        issue: "`else` block is not indented."
        solution: |
          y = -3

          if y > 0:
              print("y is positive")
              print("This is always printed")
          else:
              print("y is not positive")

      - id: if-fix-009
        difficulty: easy
        prompt: |
          Fix the loop condition that causes the while loop to never execute.
        code: |
          count = 10

          while count > 10:
              print("This will never print")
              count -= 1
        hint: Change the condition so the loop runs at least once.
        issue: Initial condition is false, loop never runs.
        solution: |
          count = 10

          while count >= 0:
              print("Count:", count)
              count -= 1

      - id: if-fix-010
        difficulty: medium
        prompt: |
          Fix the incorrect use of step in `range`.
        code: |
          for i in range(1, 10, -1):
              print(i)
        hint: A negative step requires the start value to be greater than the stop value.
        issue: Loop never runs due to range direction mismatch.
        solution: |
          for i in range(10, 0, -1):
              print(i)

      - id: if-fix-011
        difficulty: medium
        prompt: |
          Fix the incorrect usage of the `else` block in the loop.
        code: |
          for i in range(5):
              if i == 2:
                  break
              else:
                  print(i)
        hint: The `else` here is tied to `if`, not the `for` loop.
        issue: The `else` block is misleading inside the loop.
        solution: |
          for i in range(5):
              if i == 2:
                  break
              print(i)
          else:
              print("Loop completed without a break")

      - id: if-fix-012
        difficulty: medium
        prompt: |
          Handle the correct exception for division by zero.
        code: |
          try:
              print(5 / 0)
          except TypeError:
              print("A TypeError occurred")
        hint: Understand what kind of error is raised by dividing by zero.
        issue: Catching the wrong exception type.
        solution: |
          try:
              print(5 / 0)
          except ZeroDivisionError:
              print("You can't divide by zero!")

      - id: if-fix-013
        difficulty: medium
        prompt: |
          Remove the unreachable print statement after a `continue`.
        code: |
          for i in range(5):
              if i == 3:
                  continue
                  print("This will never be printed")
              print(i)
        hint: Code after `continue` is never executed.
        issue: Unreachable code after `continue`.
        solution: |
          for i in range(5):
              if i == 3:
                  continue
              print(i)

      - id: if-fix-014
        difficulty: medium
        prompt: |
          Refactor the logic to better reflect specific numeric ranges.
        code: |
          z = 20

          if z > 30:
              print("z is greater than 30")
          elif z > 10:
              print("z is greater than 10")
          else:
              print("z is less than 10")
        hint: Add more precise conditions if needed.
        issue: Ranges are too broad and overlap logically.
        solution: |
          z = 20

          if z > 30:
              print("z is greater than 30")
          elif z > 20:
              print("z is greater than 20 but less than 30")
          elif z > 10:
              print("z is greater than 10")
          else:
              print("z is less than or equal to 10")

      - id: if-fix-015
        difficulty: easy
        prompt: |
          What will happen when you use `break` incorrectly with a `for-else` loop?
        code: |
          for i in range(5):
              print(i)
          else:
              break
        hint: "`break` cannot be used outside of a loop body."
        issue: "`break` is used in an invalid position."
        solution: |
          # Cannot use `break` directly in an `else` clause of a loop
          for i in range(5):
              print(i)
          # Removed invalid `break`

      - id: if-fix-016
        difficulty: medium
        prompt: |
          Understand how `pass` works and fix the unintended print behavior.
        code: |
          for i in range(5):
              if i == 2:
                  pass
                  print("This should not print")
              print(i)
        hint: "`pass` does nothing; code after it still runs."
        issue: Misconception about how `pass` affects control flow.
        solution: |
          for i in range(5):
              if i == 2:
                  pass
              print(i)

      - id: if-fix-017
        difficulty: medium
        prompt: |
          Rearrange exception handling to use `finally` correctly.
        code: |
          try:
              result = 10 / 0
          finally:
              print("This will run no matter what.")
          except ZeroDivisionError:
              print("You can't divide by zero!")
        hint: "`finally` must follow the `except` block."
        issue: Misplaced `finally` block causes syntax error.
        solution: |
          try:
              result = 10 / 0
          except ZeroDivisionError:
              print("You can't divide by zero!")
          finally:
              print("This will run no matter what.")


  - topic: lists
    questions:
      - id: list-fix-001
        difficulty: easy
        prompt: |
          Fix the list creation error:
        code: |
          fruits = ['apple', 'banana', 'orange']
          print(fruits[3])
        hint: Remember how list indexing works in Python.
        issue: Trying to access an index that's out of range.
        solution: |
          fruits = ['apple', 'banana', 'orange']
          print(fruits[2])  # Last element is at index 2 (0-based indexing)

      - id: list-fix-002
        difficulty: medium
        prompt: |
          Fix the list slicing operation:
        code: |
          numbers = [0, 1, 2, 3, 4, 5]
          middle = numbers[2:4]
          print(middle[-1])  # Should print 4
        hint: Check the slice end index and negative indexing.
        issue: The slice doesn't include the desired last element.
        solution: |
          numbers = [0, 1, 2, 3, 4, 5]
          middle = numbers[2:5]  # or numbers[2:]
          print(middle[-1])  # Now correctly prints 4

      - id: list-fix-003
        difficulty: medium
        prompt: |
          Fix the list method usage:
        code: |
          items = [1, 2, 3]
          items.append([4, 5])
          print(items)  # Should show [1, 2, 3, 4, 5]
        hint: Check the difference between append() and extend().
        issue: append() adds the entire list as a single element.
        solution: |
          items = [1, 2, 3]
          items.extend([4, 5])  # or items += [4, 5]
          print(items)  # Now correctly shows [1, 2, 3, 4, 5]

      - id: list-fix-004
        difficulty: hard
        prompt: |
          Fix the list reverse operation:
        code: |
          values = [10, 20, 30, 40]
          reversed_values = values.reverse()
          print(reversed_values)  # Should print [40, 30, 20, 10]
        hint: Remember that some list methods modify in-place and return None.
        issue: reverse() modifies the list in-place and returns None.
        solution: |
          # Solution 1: Use the method then print the original
          values = [10, 20, 30, 40]
          values.reverse()
          print(values)

          # Solution 2: Use slicing to create a reversed copy
          values = [10, 20, 30, 40]
          reversed_values = values[::-1]
          print(reversed_values)

      - id: list-fix-005
        difficulty: easy
        prompt: |
          Fix the list element removal:
        code: |
          colors = ['red', 'green', 'blue']
          colors.remove('yellow')
          print(colors)
        hint: What happens when removing a non-existent element?
        issue: Trying to remove an element that doesn't exist in the list.
        solution: |
          colors = ['red', 'green', 'blue']
          if 'yellow' in colors:
              colors.remove('yellow')
          print(colors)  # Now won't raise ValueError

  - topic: strings
    questions:
      - id: str-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect string concatenation:
        code: |
          name = "Alice"
          age = 25
          message = "Hello " + name + ", you are " + age + " years old."
          print(message)
        hint: You can't concatenate strings with integers directly in Python. Consider using string formatting.
        issue: Trying to concatenate strings with integers using the + operator causes a TypeError.
        solution: |
          name = "Alice"
          age = 25
          message = "Hello " + name + ", you are " + str(age) + " years old."
          print(message)
          # Or using f-strings (Python 3.6+):
          # message = f"Hello {name}, you are {age} years old."

      - id: str-fix-002
        difficulty: easy
        prompt: |
          Fix the incorrect string formatting:
        code: |
          item = "book"
          price = 19.99
          print("%s costs %d" % (item, price))
        hint: The format specifier doesn't match the variable type. %d is for integers.
        issue: Using %d for a floating-point number truncates the decimal places.
        solution: |
          item = "book"
          price = 19.99
          print("%s costs %.2f" % (item, price))
          # Or using f-strings:
          # print(f"{item} costs {price:.2f}")

      - id: str-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect string concatenation:
        code: |
          first_name = "John"
          last_name = "Doe"
          full_name = first_name + last_name
          print(full_name)
        hint: Missing a space between first and last name.
        issue: The names are concatenated without a space, resulting in "JohnDoe".
        solution: |
          first_name = "John"
          last_name = "Doe"
          full_name = first_name + " " + last_name
          print(full_name)

      - id: str-fix-002
        difficulty: easy
        prompt: |
          Fix the code that tries to access a character in a string:
        code: |
          word = "Python"
          first_char = word[0]
          last_char = word[6]
          print(first_char, last_char)
        hint: Python strings are zero-indexed, and the last index is len(string) - 1.
        issue: Index 6 is out of range for "Python" (valid indices are 0 to 5).
        solution: |
          word = "Python"
          first_char = word[0]
          last_char = word[-1]  # or word[5]
          print(first_char, last_char)

      - id: str-fix-003
        difficulty: easy
        prompt: |
          Fix the incorrect string slicing:
        code: |
          text = "Hello, World!"
          substring = text[7:12]
          print(substring)
        hint: Check the indices for "World!" in the string.
        issue: The slice [7:12] gives "World" but misses the "!".
        solution: |
          text = "Hello, World!"
          substring = text[7:13]  # or text[7:]
          print(substring)

      - id: str-fix-004
        difficulty: easy
        prompt: |
          Fix the incorrect f-string usage:
        code: |
          name = "Alice"
          age = 30
          print(f"Name: {name}, Age: {age}")
        hint: The f-string syntax is correct, but the output format could be improved.
        issue: The output is correct but lacks proper spacing/punctuation.
        solution: |
          name = "Alice"
          age = 30
          print(f"Name: {name}, Age: {age}.")  # Added a period for better formatting

      - id: str-fix-005
        difficulty: easy
        prompt: |
          Fix the incorrect .format() method usage:
        code: |
          item = "coffee"
          price = 2.5
          print("The {} costs {}".format(price, item))
        hint: The order of arguments in .format() matters.
        issue: The placeholders and variables are in the wrong order.
        solution: |
          item = "coffee"
          price = 2.5
          print("The {} costs ${}".format(item, price))

      - id: str-fix-006
        difficulty: easy
        prompt: |
          Fix the incorrect %-formatting:
        code: |
          x = 10
          y = 3
          print("Division result: %d" % (x / y))
        hint: "%d is for integers, but the result is a float."
        issue: Using %d truncates the decimal part of the division.
        solution: |
          x = 10
          y = 3
          print("Division result: %.2f" % (x / y))  # Shows 2 decimal places

  - topic: operators
    questions:
      - id: op-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect exponentiation operation:
        code: |
          result = 2 ^ 3
          print(result)
        hint: Python uses a different operator for exponentiation than some other languages.
        issue: The caret (^) is a bitwise XOR operator, not exponentiation.
        solution: |
          result = 2 ** 3
          print(result)

      - id: op-fix-002
        difficulty: medium
        prompt: |
          Fix the floating-point division issue:
        code: |
          average = (3 + 5 + 2) / 0
          print(average)
        hint: Division by zero is mathematically undefined.
        issue: Attempting to divide by zero will raise a ZeroDivisionError.
        solution: |
          average = (3 + 5 + 2) / 3  # Using correct divisor
          print(average)

      - id: op-fix-003
        difficulty: easy
        prompt: |
          Fix the augmented assignment operation:
        code: |
          count = 5
          count =+ 2
          print(count)
        hint: The order of characters in augmented assignment matters.
        issue: "<b>=+</b> is not a valid operator (it's assigning positive 2, not adding)."
        solution: |
          count = 5
          count += 2
          print(count)

      - id: op-fix-004
        difficulty: medium
        prompt: |
          Fix the chained comparison:
        code: |
          x = 5
          if 1 < x > 10:
              print("In range")
        hint: Chained comparisons must express a consistent relationship.
        issue: The condition can never be True (x cannot be both >1 and >10).
        solution: |
          x = 5
          if 1 < x < 10:
              print("In range")

      - id: op-fix-005
        difficulty: medium
        prompt: |
          Fix the logical operation:
        code: |
          is_valid = True
          is_active = False
          if is_valid and is_active or:
              print("Access granted")
        hint: The 'or' operator requires a second operand.
        issue: Incomplete logical expression after 'or'.
        solution: |
          is_valid = True
          is_active = False
          if is_valid and is_active:
              print("Access granted")

      - id: op-fix-006
        difficulty: hard
        prompt: |
          Fix the bitwise operation:
        code: |
          flags = 0b1010
          mask = 0b1100
          result = flags and mask
          print(bin(result))
        hint: This is using logical AND instead of bitwise AND.
        issue: "'and' is a boolean operator, not bitwise."
        solution: |
          flags = 0b1010
          mask = 0b1100
          result = flags & mask
          print(bin(result))

      - id: op-fix-007
        difficulty: hard
        prompt: |
          Fix the operation to correctly calculate the average:
        code: |
          a, b, c = 10, 20, 30
          average = a + b + c / 3
          print(average)
        hint: Division has higher precedence than addition.
        issue: Only 'c' is being divided by 3 due to precedence rules.
        solution: |
          a, b, c = 10, 20, 30
          average = (a + b + c) / 3
          print(average)

      - id: op-fix-008
        difficulty: easy
        prompt: |
          Fix the membership test:
        code: |
          name = "Alice"
          if name in ["Bob", "Charlie", "Dave"]:
              print("Found")
        hint: The code works but doesn't match the likely intention.
        issue: Testing for "Alice" in a list that doesn't contain it.
        solution: |
          name = "Alice"
          if name in ["Alice", "Bob", "Charlie"]:
              print("Found")

      - id: op-fix-009
        difficulty: medium
        prompt: |
          Fix the identity comparison:
        code: |
          x = [1, 2, 3]
          y = [1, 2, 3]
          if x is y:
              print("Same object")
        hint: "'is' checks for object identity, not equality."
        issue: Two different list objects with same values.
        solution: |
          x = [1, 2, 3]
          y = [1, 2, 3]
          if x == y:
              print("Equal values")

  - topic: variables
    questions:
      - id: var-fix-001
        difficulty: easy
        prompt: |
          Fix the invalid variable name:
        code: |
          global-var = 10
          print(global-var)
        hint: Python variable names cannot contain hyphens.
        issue: Hyphens are interpreted as subtraction operators.
        solution: |
          global_var = 10
          print(global_var)

      - id: var-fix-002
        difficulty: easy
        prompt: |
          Fix the variable assignment error:
        code: |
          print(message)
          message = "Hello"
        hint: Variables must be defined before use.
        issue: Trying to access `message` before assignment.
        solution: |
          message = "Hello"
          print(message)

      - id: dyn-fix-001
        difficulty: medium
        prompt: |
          Fix the type confusion bug:
        code: |
          price = "10"
          total = price * 2
          print(total)  # Outputs "1010" (unexpected)
        hint: Strings and numbers behave differently with `*`.
        issue: Dynamic typing allows the operation but produces undesired string concatenation.
        solution: |
          price = 10  # or int("10")
          total = price * 2
          print(total)  # Outputs 20

      - id: dyn-fix-002
        difficulty: hard
        prompt: |
          Fix the dynamic typing pitfall:
        code: |
          def add(a, b):
              return a + b
          
          print(add(5, 3))     # 8
          print(add("5", "3")) # "53" (unexpected for numbers)
        hint: The `+` operator has different behaviors per type.
        issue: Function works differently with strings vs numbers.
        solution: |
          def add(a, b):
              return int(a) + int(b)

      - id: none-fix-001
        difficulty: easy
        prompt: |
          Fix the None comparison:
        code: |
          result = None
          if result == None:  # Works but non-idiomatic
              print("Empty")
        hint: Python has a dedicated operator for `None` checks.
        issue: Should use identity comparison (`is`) for `None`.
        solution: |
          result = None
          if result is None:
              print("Empty")

      - id: none-fix-002
        difficulty: medium
        prompt: |
          Fix the None-related crash:
        code: |
          def get_user():
              return None
          
          user = get_user()
          print(user.upper())  # AttributeError
        hint: Methods can't be called on `None`.
        issue: Attempting to call `.upper()` on a `None` value.
        solution: |
          def get_user():
              return None
          
          user = get_user()
          if user is not None:
              print(user.upper())
          else:
              print("No user found")

  - topic: oop-encapsulation
    questions:
      - id: py-encap-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the encapsulation mistake in the following code:
        code: |
          class BankAccount:
              def __init__(self, balance):
                  self.balance = balance

              def withdraw(self, amount):
                  if amount > self.balance:
                      print("Insufficient funds")
                  self.balance -= amount
        hint: Direct access to attributes violates encapsulation principles.
        issue: The balance attribute is directly accessible and modifiable from outside the class.
        solution: |
          class BankAccount:
              def __init__(self, balance):
                  self._balance = balance

              def withdraw(self, amount):
                  if amount > self._balance:
                      print("Insufficient funds")
                      return
                  self._balance -= amount

              def get_balance(self):
                  return self._balance

      - id: py-encap-fix-002
        difficulty: easy
        prompt: |
          Fix the encapsulation issue in this temperature class:
        code: |
          class Temperature:
              def __init__(self, celsius):
                  self.celsius = celsius
        hint: Temperature values should have validation to prevent impossible values.
        issue: Direct attribute access allows setting invalid temperatures.
        solution: |
          class Temperature:
              def __init__(self, celsius):
                  self._celsius = celsius

              @property
              def celsius(self):
                  return self._celsius

              @celsius.setter
              def celsius(self, value):
                  if value < -273.15:
                      raise ValueError("Temperature below absolute zero")
                  self._celsius = value

      - id: py-encap-fix-003
        difficulty: medium
        prompt: |
          Find and fix the encapsulation problems in this student class:
        code: |
          class Student:
              def __init__(self, name, grades):
                  self.name = name
                  self.grades = grades
        hint: Both attributes need protection and grades should have controlled modification.
        issue: Direct access to both name and grades violates encapsulation.
        solution: |
          class Student:
              def __init__(self, name, grades):
                  self._name = name
                  self._grades = list(grades)

              @property
              def name(self):
                  return self._name

              def add_grade(self, grade):
                  self._grades.append(grade)

              def get_grades(self):
                  return tuple(self._grades)

      - id: py-encap-fix-004
        difficulty: medium
        prompt: |
          Identify and fix the property implementation mistake:
        code: |
          class Circle:
              def __init__(self, radius):
                  self.__radius = radius

              @property
              def radius(self):
                  return self.__radius

              @radius.setter
              def radius(self, value):
                  self.radius = value
        hint: The setter is causing infinite recursion.
        issue: Using self.radius instead of self.__radius in the setter.
        solution: |
          class Circle:
              def __init__(self, radius):
                  self.__radius = radius

              @property
              def radius(self):
                  return self.__radius

              @radius.setter
              def radius(self, value):
                  if value <= 0:
                      raise ValueError("Radius must be positive")
                  self.__radius = value

      - id: py-encap-fix-005
        difficulty: hard
        prompt: |
          Fix the multiple encapsulation issues in this shopping cart implementation:
        code: |
          class ShoppingCart:
              def __init__(self):
                  self.items = []
                  self.total = 0

              def add_item(self, item, price):
                  self.items.append((item, price))
                  self.total += price
        hint: Both the items list and total should be protected from direct modification.
        issue: External code can directly modify items and total, breaking consistency.
        solution: |
          class ShoppingCart:
              def __init__(self):
                  self._items = []
                  self._total = 0

              def add_item(self, item, price):
                  self._items.append((item, price))
                  self._total += price

              def get_items(self):
                  return tuple(self._items)

              def get_total(self):
                  return self._total

              def remove_item(self, index):
                  if 0 <= index < len(self._items):
                      item, price = self._items.pop(index)
                      self._total -= price

  - topic: oop-inheritance
    questions:
      - id: py-inh-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Father:
              def __init__(self, name):
                  name = name

          class Child(Father):
              pass

          c = Child("Ali")
          print(c.name)
        hint: Remember to use `self` when assigning instance variables inside a constructor.
        issue: The constructor assigns the parameter to itself instead of using `self.name = name`.
        solution: |
          class Father:
              def __init__(self, name):
                  self.name = name

      - id: py-inh-fix-002
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Animal:
              def sound():
                  print("Some sound")

          class Dog(Animal):
              pass

          d = Dog()
          d.sound()
        hint: Instance methods need to accept the instance (`self`) as the first argument.
        issue: Method `sound()` is missing the `self` parameter.
        solution: |
          class Animal:
              def sound(self):
                  print("Some sound")

      - id: py-inh-fix-003
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Person:
              def __init__(self, name):
                  self.name = name

          class Student(Person):
              def __init__(self, school):
                  self.school = school
        hint: When overriding `__init__`, make sure to call the parent class constructor if needed.
        issue: Child constructor does not call the parent constructor, missing initialization of `name`.
        solution: |
          class Student(Person):
              def __init__(self, name, school):
                  super().__init__(name)
                  self.school = school
  
      - id: py-inh-fix-004
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class A:
              def show(self):
                  print("Class A")

          class B(A):
              def show(self):
                  print("Class B")

          obj = A()
          obj.show()
        hint: Change the code so that an object of `B` calls the `show` method of `A`.
        issue: Method `show()` in class `B` is overriding `A`'s method without calling it.
        solution: |
          class B(A):
              def show(self):
                  super().show()

      - id: py-inh-fix-005
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Vehicle:
              def __init__(self, brand):
                  self.brand = brand

          class Car(Vehicle):
              def __init__(self, model):
                  self.model = model  # Error: Forgot super().__init__

          car = Car("Tesla", "Model S")  # Throws error
        hint: Add `super().__init__(brand)` in `Car.__init__` to initialize the parent class.
        issue: "`Car` doesn't call `Vehicle.__init__`, so the parent class `brand` is not initialized."
        solution: |
          class Car(Vehicle):
              def __init__(self, brand, model):
                  super().__init__(brand)
                  self.model = model

      - id: py-inh-fix-006
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Parent:
              def show(self):
                  print("Parent method")

          class Child(Parent):
              def show(self):
                  print("Child method")  # Error: Parent method not called

          child = Child()
          child.show()  # Only shows "Child method"
        hint: Add `super().show()` in `Child`'s `show()` method to preserve the parent method.
        issue: Parent method is not called in `Child`'s overridden method.
        solution: |
          class Child(Parent):
              def show(self):
                  super().show()
                  print("Child method")

      - id: py-inh-fix-007
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Parent1:
              def display(self):
                  print("Parent1")

          class Parent2:
              def display(self):
                  print("Parent2")

          class Child(Parent1, Parent2):
              pass  # Which display() is called?

          obj = Child()
          obj.display()  # Outputs "Parent1" - is this intended?
        hint: Change inheritance order to `(Parent2, Parent1)` to control which method is called.
        issue: The method resolution order (MRO) may be confusing when multiple parent classes are involved.
        solution: |
          class Child(Parent2, Parent1):
              pass

      - id: py-inh-fix-008
        difficulty: medium
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Base:
              def __init__(self):
                  self.__secret = 123  # Name mangled

          class Derived(Base):
              def get_secret(self):
                  return self.__secret  # Error: AttributeError

          d = Derived()
          print(d.get_secret())
        hint: "You cannot directly access a private attribute from a subclass."
        issue: "Derived tries to access `__secret`, which is name-mangled."
        solution: |
          class Derived(Base):
              def get_secret(self):
                  return self._Base__secret  # Access the mangled name

      - id: py-inh-fix-009
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Engine:
              def start(self):
                  print("Engine started")

          class Car(Engine):  # Bad inheritance
              def drive(self):
                  self.start()

          car = Car()
          car.drive()  # Works but poor design
        hint: Use composition rather than inheritance in this case.
        issue: "`Car` class should not inherit from `Engine` as it does not represent an is-a relationship."
        solution: |
          class Car:
              def __init__(self):
                  self.engine = Engine()

              def drive(self):
                  self.engine.start()

      - id: py-inh-fix-010
        difficulty: hard
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class MathOps:
              @staticmethod
              def add(a, b):
                  return a + b

          class AdvancedMath(MathOps):
              def add(a, b, c):  # Missing @staticmethod
                  return a + b + c

          result = AdvancedMath.add(1, 2, 3)  # TypeError
        hint: Add `@staticmethod` decorator to `add` method in `AdvancedMath`.
        issue: "`AdvancedMath.add` should be a static method but the decorator is missing."
        solution: |
          class AdvancedMath(MathOps):
              @staticmethod
              def add(a, b, c):
                  return a + b + c

      - id: py-inh-fix-011
        difficulty: medium
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class A:
              def __init__(self):
                  print("A initialized")

          class B(A):
              def __init__(self):
                  super().__init__()
                  print("B initialized")

          class C(A):
              def __init__(self):
                  super().__init__()
                  print("C initialized")

          class D(B, C):
              def __init__(self):
                  super().__init__()  # Initializes B -> C -> A
                  print("D initialized")

          d = D()  # Output order might surprise beginners
        hint: Analyze MRO with `print(D.__mro__)`.
        issue: The MRO might cause confusion due to multiple inheritance.
        solution: |
          class D(B, C):
              def __init__(self):
                  super().__init__()
                  print("D initialized")

      - id: py-inh-fix-012
        difficulty: hard
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Account:
              @property
              def balance(self):
                  return self._balance

          class Savings(Account):
              def balance(self):  # Forgot @property
                  return self._balance * 1.05  # Broken

          sa = Savings()
          sa.balance  # Throws AttributeError
        hint: Use `@property` decorator in `Savings` to override `balance` method as a property.
        issue: "balance becomes a method instead of a property in `Savings`."
        solution: |
          class Savings(Account):
              @property
              def balance(self):
                  return self._balance * 1.05

      - id: py-inh-fix-013
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Shape:
              def __init__(self, color):
                  self.color = color

          class Circle(Shape):
              def __init__(self, radius):
                  super().__init__()  # Error: Missing color arg
                  self.radius = radius

          c = Circle("red", 5)  # TypeError
        hint: Pass `color` argument when calling `super().__init__()`.
        issue: "Circle class does not pass the `color` argument when calling `super().__init__()`."
        solution: |
          class Circle(Shape):
              def __init__(self, color, radius):
                  super().__init__(color)
                  self.radius = radius

      - id: py-inh-fix-014
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          name = "BaseClass"

          class MyClass(name):  # Error: 'str' is not a class
              pass
        hint: You cannot inherit from a non-class type.
        issue: Trying to inherit from a string instead of a class.
        solution: |
          class MyClass(object):  # Inherit from the base class `object`
              pass
    resources:
      - name: Learn Inheritance in Python
        url: https://yasirbhutta.github.io/python/docs/oop-inheritance.html

  - topic: lambda
    questions:
      - id: py-lambda-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          add = lambda x: return x + 10
          print(add(5))
        hint: ""
        issue: The `return` keyword is incorrectly used inside a lambda function.
        solution: |
          add = lambda x: x + 10
          print(add(5))

      - id: py-lambda-fix-003
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          result = (lambda x, y : x + y)(6)
          print(result)
        hint: ""
        issue: The lambda function expects two arguments but only one is given during invocation.
        solution: |
          result = (lambda x, y : x + y)(6, 8)
          print(result)

      - id: py-lambda-fix-004
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          mul = lambda a, b: a * b
          print(mul(2, 4, 6))
        hint: ""
        issue: Too many arguments passed to a lambda function that expects only two.
        solution: |
          mul = lambda a, b: a * b
          print(mul(2, 4))

      - id: py-lambda-fix-005
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          (lambda x, y : x + y)(6 8)
        hint: Check for syntax issues in function invocation.
        issue: Missing a comma between arguments when calling the lambda function.
        solution: |
          (lambda x, y : x + y)(6, 8)
