course: python
topics:

  - topic: strings
    questions:
      - id: str-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect string concatenation:
        code: |
          name = "Alice"
          age = 25
          message = "Hello " + name + ", you are " + age + " years old."
          print(message)
        hint: You can't concatenate strings with integers directly in Python. Consider using string formatting.
        issue: Trying to concatenate strings with integers using the + operator causes a TypeError.
        solution: |
          name = "Alice"
          age = 25
          message = "Hello " + name + ", you are " + str(age) + " years old."
          print(message)
          # Or using f-strings (Python 3.6+):
          # message = f"Hello {name}, you are {age} years old."

      - id: str-fix-002
        difficulty: easy
        prompt: |
          Fix the incorrect string formatting:
        code: |
          item = "book"
          price = 19.99
          print("%s costs %d" % (item, price))
        hint: The format specifier doesn't match the variable type. %d is for integers.
        issue: Using %d for a floating-point number truncates the decimal places.
        solution: |
          item = "book"
          price = 19.99
          print("%s costs %.2f" % (item, price))
          # Or using f-strings:
          # print(f"{item} costs {price:.2f}")

      - id: str-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect string concatenation:
        code: |
          first_name = "John"
          last_name = "Doe"
          full_name = first_name + last_name
          print(full_name)
        hint: Missing a space between first and last name.
        issue: The names are concatenated without a space, resulting in "JohnDoe".
        solution: |
          first_name = "John"
          last_name = "Doe"
          full_name = first_name + " " + last_name
          print(full_name)

      - id: str-fix-002
        difficulty: easy
        prompt: |
          Fix the code that tries to access a character in a string:
        code: |
          word = "Python"
          first_char = word[0]
          last_char = word[6]
          print(first_char, last_char)
        hint: Python strings are zero-indexed, and the last index is len(string) - 1.
        issue: Index 6 is out of range for "Python" (valid indices are 0 to 5).
        solution: |
          word = "Python"
          first_char = word[0]
          last_char = word[-1]  # or word[5]
          print(first_char, last_char)

      - id: str-fix-003
        difficulty: easy
        prompt: |
          Fix the incorrect string slicing:
        code: |
          text = "Hello, World!"
          substring = text[7:12]
          print(substring)
        hint: Check the indices for "World!" in the string.
        issue: The slice [7:12] gives "World" but misses the "!".
        solution: |
          text = "Hello, World!"
          substring = text[7:13]  # or text[7:]
          print(substring)

      - id: str-fix-004
        difficulty: easy
        prompt: |
          Fix the incorrect f-string usage:
        code: |
          name = "Alice"
          age = 30
          print(f"Name: {name}, Age: {age}")
        hint: The f-string syntax is correct, but the output format could be improved.
        issue: The output is correct but lacks proper spacing/punctuation.
        solution: |
          name = "Alice"
          age = 30
          print(f"Name: {name}, Age: {age}.")  # Added a period for better formatting

      - id: str-fix-005
        difficulty: easy
        prompt: |
          Fix the incorrect .format() method usage:
        code: |
          item = "coffee"
          price = 2.5
          print("The {} costs {}".format(price, item))
        hint: The order of arguments in .format() matters.
        issue: The placeholders and variables are in the wrong order.
        solution: |
          item = "coffee"
          price = 2.5
          print("The {} costs ${}".format(item, price))

      - id: str-fix-006
        difficulty: easy
        prompt: |
          Fix the incorrect %-formatting:
        code: |
          x = 10
          y = 3
          print("Division result: %d" % (x / y))
        hint: "%d is for integers, but the result is a float."
        issue: Using %d truncates the decimal part of the division.
        solution: |
          x = 10
          y = 3
          print("Division result: %.2f" % (x / y))  # Shows 2 decimal places

  - topic: operators
    questions:
      - id: op-fix-001
        difficulty: easy
        prompt: |
          Fix the incorrect exponentiation operation:
        code: |
          result = 2 ^ 3
          print(result)
        hint: Python uses a different operator for exponentiation than some other languages.
        issue: The caret (^) is a bitwise XOR operator, not exponentiation.
        solution: |
          result = 2 ** 3
          print(result)

      - id: op-fix-002
        difficulty: medium
        prompt: |
          Fix the floating-point division issue:
        code: |
          average = (3 + 5 + 2) / 0
          print(average)
        hint: Division by zero is mathematically undefined.
        issue: Attempting to divide by zero will raise a ZeroDivisionError.
        solution: |
          average = (3 + 5 + 2) / 3  # Using correct divisor
          print(average)

      - id: op-fix-003
        difficulty: easy
        prompt: |
          Fix the augmented assignment operation:
        code: |
          count = 5
          count =+ 2
          print(count)
        hint: The order of characters in augmented assignment matters.
        issue: "<b>=+</b> is not a valid operator (it's assigning positive 2, not adding)."
        solution: |
          count = 5
          count += 2
          print(count)

      - id: op-fix-004
        difficulty: medium
        prompt: |
          Fix the chained comparison:
        code: |
          x = 5
          if 1 < x > 10:
              print("In range")
        hint: Chained comparisons must express a consistent relationship.
        issue: The condition can never be True (x cannot be both >1 and >10).
        solution: |
          x = 5
          if 1 < x < 10:
              print("In range")

      - id: op-fix-005
        difficulty: medium
        prompt: |
          Fix the logical operation:
        code: |
          is_valid = True
          is_active = False
          if is_valid and is_active or:
              print("Access granted")
        hint: The 'or' operator requires a second operand.
        issue: Incomplete logical expression after 'or'.
        solution: |
          is_valid = True
          is_active = False
          if is_valid and is_active:
              print("Access granted")

      - id: op-fix-006
        difficulty: hard
        prompt: |
          Fix the bitwise operation:
        code: |
          flags = 0b1010
          mask = 0b1100
          result = flags and mask
          print(bin(result))
        hint: This is using logical AND instead of bitwise AND.
        issue: "'and' is a boolean operator, not bitwise."
        solution: |
          flags = 0b1010
          mask = 0b1100
          result = flags & mask
          print(bin(result))

      - id: op-fix-007
        difficulty: hard
        prompt: |
          Fix the operation to correctly calculate the average:
        code: |
          a, b, c = 10, 20, 30
          average = a + b + c / 3
          print(average)
        hint: Division has higher precedence than addition.
        issue: Only 'c' is being divided by 3 due to precedence rules.
        solution: |
          a, b, c = 10, 20, 30
          average = (a + b + c) / 3
          print(average)

      - id: op-fix-008
        difficulty: easy
        prompt: |
          Fix the membership test:
        code: |
          name = "Alice"
          if name in ["Bob", "Charlie", "Dave"]:
              print("Found")
        hint: The code works but doesn't match the likely intention.
        issue: Testing for "Alice" in a list that doesn't contain it.
        solution: |
          name = "Alice"
          if name in ["Alice", "Bob", "Charlie"]:
              print("Found")

      - id: op-fix-009
        difficulty: medium
        prompt: |
          Fix the identity comparison:
        code: |
          x = [1, 2, 3]
          y = [1, 2, 3]
          if x is y:
              print("Same object")
        hint: "'is' checks for object identity, not equality."
        issue: Two different list objects with same values.
        solution: |
          x = [1, 2, 3]
          y = [1, 2, 3]
          if x == y:
              print("Equal values")

  - topic: variables
    questions:
      - id: var-fix-001
        difficulty: easy
        prompt: |
          Fix the invalid variable name:
        code: |
          global-var = 10
          print(global-var)
        hint: Python variable names cannot contain hyphens.
        issue: Hyphens are interpreted as subtraction operators.
        solution: |
          global_var = 10
          print(global_var)

      - id: var-fix-002
        difficulty: easy
        prompt: |
          Fix the variable assignment error:
        code: |
          print(message)
          message = "Hello"
        hint: Variables must be defined before use.
        issue: Trying to access `message` before assignment.
        solution: |
          message = "Hello"
          print(message)

      - id: dyn-fix-001
        difficulty: medium
        prompt: |
          Fix the type confusion bug:
        code: |
          price = "10"
          total = price * 2
          print(total)  # Outputs "1010" (unexpected)
        hint: Strings and numbers behave differently with `*`.
        issue: Dynamic typing allows the operation but produces undesired string concatenation.
        solution: |
          price = 10  # or int("10")
          total = price * 2
          print(total)  # Outputs 20

      - id: dyn-fix-002
        difficulty: hard
        prompt: |
          Fix the dynamic typing pitfall:
        code: |
          def add(a, b):
              return a + b
          
          print(add(5, 3))     # 8
          print(add("5", "3")) # "53" (unexpected for numbers)
        hint: The `+` operator has different behaviors per type.
        issue: Function works differently with strings vs numbers.
        solution: |
          def add(a, b):
              return int(a) + int(b)

      - id: none-fix-001
        difficulty: easy
        prompt: |
          Fix the None comparison:
        code: |
          result = None
          if result == None:  # Works but non-idiomatic
              print("Empty")
        hint: Python has a dedicated operator for `None` checks.
        issue: Should use identity comparison (`is`) for `None`.
        solution: |
          result = None
          if result is None:
              print("Empty")

      - id: none-fix-002
        difficulty: medium
        prompt: |
          Fix the None-related crash:
        code: |
          def get_user():
              return None
          
          user = get_user()
          print(user.upper())  # AttributeError
        hint: Methods can't be called on `None`.
        issue: Attempting to call `.upper()` on a `None` value.
        solution: |
          def get_user():
              return None
          
          user = get_user()
          if user is not None:
              print(user.upper())
          else:
              print("No user found")

  - topic: oop-encapsulation
    questions:
      - id: py-encap-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the encapsulation mistake in the following code:
        code: |
          class BankAccount:
              def __init__(self, balance):
                  self.balance = balance

              def withdraw(self, amount):
                  if amount > self.balance:
                      print("Insufficient funds")
                  self.balance -= amount
        hint: Direct access to attributes violates encapsulation principles.
        issue: The balance attribute is directly accessible and modifiable from outside the class.
        solution: |
          class BankAccount:
              def __init__(self, balance):
                  self._balance = balance

              def withdraw(self, amount):
                  if amount > self._balance:
                      print("Insufficient funds")
                      return
                  self._balance -= amount

              def get_balance(self):
                  return self._balance

      - id: py-encap-fix-002
        difficulty: easy
        prompt: |
          Fix the encapsulation issue in this temperature class:
        code: |
          class Temperature:
              def __init__(self, celsius):
                  self.celsius = celsius
        hint: Temperature values should have validation to prevent impossible values.
        issue: Direct attribute access allows setting invalid temperatures.
        solution: |
          class Temperature:
              def __init__(self, celsius):
                  self._celsius = celsius

              @property
              def celsius(self):
                  return self._celsius

              @celsius.setter
              def celsius(self, value):
                  if value < -273.15:
                      raise ValueError("Temperature below absolute zero")
                  self._celsius = value

      - id: py-encap-fix-003
        difficulty: medium
        prompt: |
          Find and fix the encapsulation problems in this student class:
        code: |
          class Student:
              def __init__(self, name, grades):
                  self.name = name
                  self.grades = grades
        hint: Both attributes need protection and grades should have controlled modification.
        issue: Direct access to both name and grades violates encapsulation.
        solution: |
          class Student:
              def __init__(self, name, grades):
                  self._name = name
                  self._grades = list(grades)

              @property
              def name(self):
                  return self._name

              def add_grade(self, grade):
                  self._grades.append(grade)

              def get_grades(self):
                  return tuple(self._grades)

      - id: py-encap-fix-004
        difficulty: medium
        prompt: |
          Identify and fix the property implementation mistake:
        code: |
          class Circle:
              def __init__(self, radius):
                  self.__radius = radius

              @property
              def radius(self):
                  return self.__radius

              @radius.setter
              def radius(self, value):
                  self.radius = value
        hint: The setter is causing infinite recursion.
        issue: Using self.radius instead of self.__radius in the setter.
        solution: |
          class Circle:
              def __init__(self, radius):
                  self.__radius = radius

              @property
              def radius(self):
                  return self.__radius

              @radius.setter
              def radius(self, value):
                  if value <= 0:
                      raise ValueError("Radius must be positive")
                  self.__radius = value

      - id: py-encap-fix-005
        difficulty: hard
        prompt: |
          Fix the multiple encapsulation issues in this shopping cart implementation:
        code: |
          class ShoppingCart:
              def __init__(self):
                  self.items = []
                  self.total = 0

              def add_item(self, item, price):
                  self.items.append((item, price))
                  self.total += price
        hint: Both the items list and total should be protected from direct modification.
        issue: External code can directly modify items and total, breaking consistency.
        solution: |
          class ShoppingCart:
              def __init__(self):
                  self._items = []
                  self._total = 0

              def add_item(self, item, price):
                  self._items.append((item, price))
                  self._total += price

              def get_items(self):
                  return tuple(self._items)

              def get_total(self):
                  return self._total

              def remove_item(self, index):
                  if 0 <= index < len(self._items):
                      item, price = self._items.pop(index)
                      self._total -= price

  - topic: oop-inheritance
    questions:
      - id: py-inh-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Father:
              def __init__(self, name):
                  name = name

          class Child(Father):
              pass

          c = Child("Ali")
          print(c.name)
        hint: Remember to use `self` when assigning instance variables inside a constructor.
        issue: The constructor assigns the parameter to itself instead of using `self.name = name`.
        solution: |
          class Father:
              def __init__(self, name):
                  self.name = name

      - id: py-inh-fix-002
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Animal:
              def sound():
                  print("Some sound")

          class Dog(Animal):
              pass

          d = Dog()
          d.sound()
        hint: Instance methods need to accept the instance (`self`) as the first argument.
        issue: Method `sound()` is missing the `self` parameter.
        solution: |
          class Animal:
              def sound(self):
                  print("Some sound")

      - id: py-inh-fix-003
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Person:
              def __init__(self, name):
                  self.name = name

          class Student(Person):
              def __init__(self, school):
                  self.school = school
        hint: When overriding `__init__`, make sure to call the parent class constructor if needed.
        issue: Child constructor does not call the parent constructor, missing initialization of `name`.
        solution: |
          class Student(Person):
              def __init__(self, name, school):
                  super().__init__(name)
                  self.school = school
  
      - id: py-inh-fix-004
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class A:
              def show(self):
                  print("Class A")

          class B(A):
              def show(self):
                  print("Class B")

          obj = A()
          obj.show()
        hint: Change the code so that an object of `B` calls the `show` method of `A`.
        issue: Method `show()` in class `B` is overriding `A`'s method without calling it.
        solution: |
          class B(A):
              def show(self):
                  super().show()

      - id: py-inh-fix-005
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Vehicle:
              def __init__(self, brand):
                  self.brand = brand

          class Car(Vehicle):
              def __init__(self, model):
                  self.model = model  # Error: Forgot super().__init__

          car = Car("Tesla", "Model S")  # Throws error
        hint: Add `super().__init__(brand)` in `Car.__init__` to initialize the parent class.
        issue: "`Car` doesn't call `Vehicle.__init__`, so the parent class `brand` is not initialized."
        solution: |
          class Car(Vehicle):
              def __init__(self, brand, model):
                  super().__init__(brand)
                  self.model = model

      - id: py-inh-fix-006
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Parent:
              def show(self):
                  print("Parent method")

          class Child(Parent):
              def show(self):
                  print("Child method")  # Error: Parent method not called

          child = Child()
          child.show()  # Only shows "Child method"
        hint: Add `super().show()` in `Child`'s `show()` method to preserve the parent method.
        issue: Parent method is not called in `Child`'s overridden method.
        solution: |
          class Child(Parent):
              def show(self):
                  super().show()
                  print("Child method")

      - id: py-inh-fix-007
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Parent1:
              def display(self):
                  print("Parent1")

          class Parent2:
              def display(self):
                  print("Parent2")

          class Child(Parent1, Parent2):
              pass  # Which display() is called?

          obj = Child()
          obj.display()  # Outputs "Parent1" - is this intended?
        hint: Change inheritance order to `(Parent2, Parent1)` to control which method is called.
        issue: The method resolution order (MRO) may be confusing when multiple parent classes are involved.
        solution: |
          class Child(Parent2, Parent1):
              pass

      - id: py-inh-fix-008
        difficulty: medium
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Base:
              def __init__(self):
                  self.__secret = 123  # Name mangled

          class Derived(Base):
              def get_secret(self):
                  return self.__secret  # Error: AttributeError

          d = Derived()
          print(d.get_secret())
        hint: "You cannot directly access a private attribute from a subclass."
        issue: "Derived tries to access `__secret`, which is name-mangled."
        solution: |
          class Derived(Base):
              def get_secret(self):
                  return self._Base__secret  # Access the mangled name

      - id: py-inh-fix-009
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Engine:
              def start(self):
                  print("Engine started")

          class Car(Engine):  # Bad inheritance
              def drive(self):
                  self.start()

          car = Car()
          car.drive()  # Works but poor design
        hint: Use composition rather than inheritance in this case.
        issue: "`Car` class should not inherit from `Engine` as it does not represent an is-a relationship."
        solution: |
          class Car:
              def __init__(self):
                  self.engine = Engine()

              def drive(self):
                  self.engine.start()

      - id: py-inh-fix-010
        difficulty: hard
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class MathOps:
              @staticmethod
              def add(a, b):
                  return a + b

          class AdvancedMath(MathOps):
              def add(a, b, c):  # Missing @staticmethod
                  return a + b + c

          result = AdvancedMath.add(1, 2, 3)  # TypeError
        hint: Add `@staticmethod` decorator to `add` method in `AdvancedMath`.
        issue: "`AdvancedMath.add` should be a static method but the decorator is missing."
        solution: |
          class AdvancedMath(MathOps):
              @staticmethod
              def add(a, b, c):
                  return a + b + c

      - id: py-inh-fix-011
        difficulty: medium
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class A:
              def __init__(self):
                  print("A initialized")

          class B(A):
              def __init__(self):
                  super().__init__()
                  print("B initialized")

          class C(A):
              def __init__(self):
                  super().__init__()
                  print("C initialized")

          class D(B, C):
              def __init__(self):
                  super().__init__()  # Initializes B -> C -> A
                  print("D initialized")

          d = D()  # Output order might surprise beginners
        hint: Analyze MRO with `print(D.__mro__)`.
        issue: The MRO might cause confusion due to multiple inheritance.
        solution: |
          class D(B, C):
              def __init__(self):
                  super().__init__()
                  print("D initialized")

      - id: py-inh-fix-012
        difficulty: hard
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Account:
              @property
              def balance(self):
                  return self._balance

          class Savings(Account):
              def balance(self):  # Forgot @property
                  return self._balance * 1.05  # Broken

          sa = Savings()
          sa.balance  # Throws AttributeError
        hint: Use `@property` decorator in `Savings` to override `balance` method as a property.
        issue: "balance becomes a method instead of a property in `Savings`."
        solution: |
          class Savings(Account):
              @property
              def balance(self):
                  return self._balance * 1.05

      - id: py-inh-fix-013
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          class Shape:
              def __init__(self, color):
                  self.color = color

          class Circle(Shape):
              def __init__(self, radius):
                  super().__init__()  # Error: Missing color arg
                  self.radius = radius

          c = Circle("red", 5)  # TypeError
        hint: Pass `color` argument when calling `super().__init__()`.
        issue: "Circle class does not pass the `color` argument when calling `super().__init__()`."
        solution: |
          class Circle(Shape):
              def __init__(self, color, radius):
                  super().__init__(color)
                  self.radius = radius

      - id: py-inh-fix-014
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          name = "BaseClass"

          class MyClass(name):  # Error: 'str' is not a class
              pass
        hint: You cannot inherit from a non-class type.
        issue: Trying to inherit from a string instead of a class.
        solution: |
          class MyClass(object):  # Inherit from the base class `object`
              pass
    resources:
      - name: Learn Inheritance in Python
        url: https://yasirbhutta.github.io/python/docs/oop-inheritance.html

  - topic: lambda
    questions:
      - id: py-lambda-fix-001
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          add = lambda x: return x + 10
          print(add(5))
        hint: ""
        issue: The `return` keyword is incorrectly used inside a lambda function.
        solution: |
          add = lambda x: x + 10
          print(add(5))

      - id: py-lambda-fix-003
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          result = (lambda x, y : x + y)(6)
          print(result)
        hint: ""
        issue: The lambda function expects two arguments but only one is given during invocation.
        solution: |
          result = (lambda x, y : x + y)(6, 8)
          print(result)

      - id: py-lambda-fix-004
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          mul = lambda a, b: a * b
          print(mul(2, 4, 6))
        hint: ""
        issue: Too many arguments passed to a lambda function that expects only two.
        solution: |
          mul = lambda a, b: a * b
          print(mul(2, 4))

      - id: py-lambda-fix-005
        difficulty: easy
        prompt: |
          Identify and fix the mistake in the following code:
        code: |
          (lambda x, y : x + y)(6 8)
        hint: Check for syntax issues in function invocation.
        issue: Missing a comma between arguments when calling the lambda function.
        solution: |
          (lambda x, y : x + y)(6, 8)
